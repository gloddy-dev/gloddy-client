
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for gloddy-client/.next/static/chunks/app/layout-e9d3aa52a9a64d60.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../../../../prettify.css" />
    <link rel="stylesheet" href="../../../../../base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="../../../../../favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../../../../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../../../../../index.html">All files</a> / <a href="index.html">gloddy-client/.next/static/chunks/app</a> layout-e9d3aa52a9a64d60.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>0/337</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>0/314</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>0/170</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>0/2</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
        <template id="filterTemplate">
            <div class="quiet">
                Filter:
                <input oninput="onInput()" type="search" id="fileSearch">
            </div>
        </template>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a>
<a name='L4'></a><a href='#L4'>4</a>
<a name='L5'></a><a href='#L5'>5</a>
<a name='L6'></a><a href='#L6'>6</a>
<a name='L7'></a><a href='#L7'>7</a>
<a name='L8'></a><a href='#L8'>8</a>
<a name='L9'></a><a href='#L9'>9</a></td><td class="line-coverage quiet"><span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">(<span class="cstat-no" title="statement not covered" >self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[185],{2376:<span class="fstat-no" title="function not covered" >function(t</span>,e,i){<span class="cstat-no" title="statement not covered" >Promise.resolve().then(i.bind(i,8998)),Promise.resolve().then(i.t.bind(i,7366,23))}</span>,8998:<span class="fstat-no" title="function not covered" >function(t</span>,e,i){"use strict";<span class="cstat-no" title="statement not covered" >i.r(e),i.d(e,{default:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn O}</span>});v</span>ar s=<span class="cstat-no" title="statement not covered" >i(5862),r</span>=<span class="cstat-no" title="statement not covered" >i(3199),n</span>=<span class="cstat-no" title="statement not covered" >i(3126),a</span>=<span class="cstat-no" title="statement not covered" >i(324),u</span>=<span class="cstat-no" title="statement not covered" >i(2425),o</span>=<span class="cstat-no" title="statement not covered" >i(5848);c</span>lass h extends o.F{<span class="fstat-no" title="function not covered" >constructor(t</span>){<span class="cstat-no" title="statement not covered" >super(),this.abortSignalConsumed=!1,this.defaultOptions=t.defaultOptions,this.setOptions(t.options),this.observers=[],this.cache=t.cache,this.logger=t.logger||n._,this.queryKey=t.queryKey,this.queryHash=t.queryHash,this.initialState=t.state||<span class="fstat-no" title="function not covered" >function(t</span>){let e=<span class="cstat-no" title="statement not covered" >"function"==typeof t.initialData?t.initialData():t.initialData,i</span>=<span class="cstat-no" title="statement not covered" >void 0!==e,s</span>=<span class="cstat-no" title="statement not covered" >i?"function"==typeof t.initialDataUpdatedAt?t.initialDataUpdatedAt():t.initialDataUpdatedAt:0;<span class="cstat-no" title="statement not covered" >r</span>eturn{data:e,dataUpdateCount:0,dataUpdatedAt:i?null!=s?s:Date.now():0,error:null,errorUpdateCount:0,errorUpdatedAt:0,fetchFailureCount:0,fetchFailureReason:null,fetchMeta:null,isInvalidated:!1,status:i?"success":"loading",fetchStatus:"idle"}}</span>(this.options),this.state=this.initialState,this.scheduleGc()}<span class="fstat-no" title="function not covered" ></span>get m</span>eta(){<span class="cstat-no" title="statement not covered" >return this.options.meta}<span class="fstat-no" title="function not covered" ></span>setOptions(t</span>){<span class="cstat-no" title="statement not covered" >this.options={...this.defaultOptions,...t},this.updateCacheTime(this.options.cacheTime)}<span class="fstat-no" title="function not covered" ></span>optionalRemove(){<span class="cstat-no" title="statement not covered" ></span>this.observers.length||"idle"!==this.state.fetchStatus||this.cache.remove(this)}<span class="fstat-no" title="function not covered" ></span>setData(t</span>,e){let i=<span class="cstat-no" title="statement not covered" >(0,r.oE)(this.state.data,t,this.options);<span class="cstat-no" title="statement not covered" >r</span>eturn this.dispatch({data:i,type:"success",dataUpdatedAt:null==e?void 0:e.updatedAt,manual:null==e?void 0:e.manual}),i}<span class="fstat-no" title="function not covered" ></span>setState(t</span>,e){<span class="cstat-no" title="statement not covered" >this.dispatch({type:"setState",state:t,setStateOptions:e})}<span class="fstat-no" title="function not covered" ></span>cancel(t</span>){var e;let i=<span class="cstat-no" title="statement not covered" >this.promise;<span class="cstat-no" title="statement not covered" >r</span>eturn null==(e=this.retryer)||e.cancel(t),i?i.then(r.ZT).catch(r.ZT):Promise.resolve()}<span class="fstat-no" title="function not covered" ></span>destroy(){<span class="cstat-no" title="statement not covered" ></span>super.destroy(),this.cancel({silent:!0})}<span class="fstat-no" title="function not covered" ></span>reset(){<span class="cstat-no" title="statement not covered" ></span>this.destroy(),this.setState(this.initialState)}<span class="fstat-no" title="function not covered" ></span>isActive(){<span class="cstat-no" title="statement not covered" ></span>return this.observers.some(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >!</span>1!==t.options.enabled)}<span class="fstat-no" title="function not covered" ></span></span>isDisabled(){<span class="cstat-no" title="statement not covered" ></span>return this.getObserversCount()&gt;0&amp;&amp;!this.isActive()}<span class="fstat-no" title="function not covered" ></span>isStale(){<span class="cstat-no" title="statement not covered" ></span>return this.state.isInvalidated||!this.state.dataUpdatedAt||this.observers.some(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >t</span>.getCurrentResult().isStale)}<span class="fstat-no" title="function not covered" ></span></span>isStaleByTime(t</span>=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{<span class="cstat-no" title="statement not covered" >return this.state.isInvalidated||!this.state.dataUpdatedAt||!(0,r.Kp)(this.state.dataUpdatedAt,t)}<span class="fstat-no" title="function not covered" ></span>onFocus(){</span>var t;let e=<span class="cstat-no" title="statement not covered" >this.observers.find(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >t</span>.shouldFetchOnWindowFocus());<span class="cstat-no" title="statement not covered" >e</span></span>&amp;&amp;e.refetch({cancelRefetch:!1}),null==(t=this.retryer)||t.continue()}<span class="fstat-no" title="function not covered" ></span>onOnline(){</span>var t;let e=<span class="cstat-no" title="statement not covered" >this.observers.find(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >t</span>.shouldFetchOnReconnect());<span class="cstat-no" title="statement not covered" >e</span></span>&amp;&amp;e.refetch({cancelRefetch:!1}),null==(t=this.retryer)||t.continue()}<span class="fstat-no" title="function not covered" ></span>addObserver(t</span>){<span class="cstat-no" title="statement not covered" >this.observers.includes(t)||(this.observers.push(t),this.clearGcTimeout(),this.cache.notify({type:"observerAdded",query:this,observer:t}))}<span class="fstat-no" title="function not covered" ></span>removeObserver(t</span>){<span class="cstat-no" title="statement not covered" >this.observers.includes(t)&amp;&amp;(this.observers=this.observers.filter(<span class="fstat-no" title="function not covered" >e=&gt;<span class="cstat-no" title="statement not covered" >e</span>!==t),t</span>his.observers.length||(this.retryer&amp;&amp;(this.abortSignalConsumed?this.retryer.cancel({revert:!0}):this.retryer.cancelRetry()),this.scheduleGc()),this.cache.notify({type:"observerRemoved",query:this,observer:t}))}<span class="fstat-no" title="function not covered" ></span>getObserversCount(){<span class="cstat-no" title="statement not covered" ></span>return this.observers.length}<span class="fstat-no" title="function not covered" ></span>invalidate(){<span class="cstat-no" title="statement not covered" ></span>this.state.isInvalidated||this.dispatch({type:"invalidate"})}<span class="fstat-no" title="function not covered" ></span>fetch(t</span>,e){var i,s,n,a;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if("idle"!==this.state.fetchStatus){<span class="cstat-no" title="statement not covered" >if(this.state.dataUpdatedAt&amp;&amp;null!=e&amp;&amp;e.cancelRefetch)<span class="cstat-no" title="statement not covered" >this.cancel({silent:!0});else <span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(this.promise)<span class="cstat-no" title="statement not covered" >return null==(n=this.retryer)||n.continueRetry(),this.promise}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span></span></span>i</span>f(t&amp;&amp;this.setOptions(t),!this.options.queryFn){let t=<span class="cstat-no" title="statement not covered" >this.observers.find(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >t</span>.options.queryFn);<span class="cstat-no" title="statement not covered" >t</span></span>&amp;&amp;this.setOptions(t.options)}<span class="cstat-no" title="statement not covered" ></span>A</span>rray.isArray(this.options.queryKey);l</span>et o=<span class="cstat-no" title="statement not covered" >(0,r.G9)(),h</span>=<span class="cstat-no" title="statement not covered" >{queryKey:this.queryKey,pageParam:void 0,meta:this.meta},l</span>=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=&gt;{<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(t,"signal",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(o)<span class="cstat-no" title="statement not covered" >return this.abortSignalConsumed=!0,o.signal}</span></span>})}</span>;<span class="cstat-no" title="statement not covered" >l</span>(h);l</span>et c=<span class="cstat-no" title="statement not covered" >{fetchOptions:e,options:this.options,queryKey:this.queryKey,state:this.state,fetchFn:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >t</span>his.options.queryFn?(this.abortSignalConsumed=!1,this.options.queryFn(h)):Promise.reject("Missing queryFn for queryKey '"+this.options.queryHash+"'")}</span>;<span class="cstat-no" title="statement not covered" >l</span>(c),null==(i=this.options.behavior)||i.onFetch(c),this.revertState=this.state,("idle"===this.state.fetchStatus||this.state.fetchMeta!==(null==(s=c.fetchOptions)?void 0:s.meta))&amp;&amp;this.dispatch({type:"fetch",meta:null==(a=c.fetchOptions)?void 0:a.meta});l</span>et d=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=&gt;{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f((0,u.DV)(t)&amp;&amp;t.silent||this.dispatch({type:"error",error:t}),!(0,u.DV)(t)){var e,i,s,r;<span class="cstat-no" title="statement not covered" >null==(e=(i=this.cache.config).onError)||e.call(i,t,this),null==(s=(r=this.cache.config).onSettled)||s.call(r,this.state.data,t,this)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.isFetchingOptimistic||this.scheduleGc(),this.isFetchingOptimistic=!1}</span>;<span class="cstat-no" title="statement not covered" >r</span>eturn this.retryer=(0,u.Mz)({fn:c.fetchFn,abort:null==o?void 0:o.abort.bind(o),onSuccess:<span class="fstat-no" title="function not covered" >t=&gt;{v</span>ar e,i,s,r;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(void 0===t){<span class="cstat-no" title="statement not covered" >d(Error(this.queryHash+" data is undefined"));<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>t</span>his.setData(t),null==(e=(i=this.cache.config).onSuccess)||e.call(i,t,this),null==(s=(r=this.cache.config).onSettled)||s.call(r,t,this.state.error,this),this.isFetchingOptimistic||this.scheduleGc(),this.isFetchingOptimistic=!1}</span>,onError:d,onFail:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >this.dispatch({type:"failed",failureCount:t,error:e})}</span>,onPause:<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >t</span>his.dispatch({type:"pause"})}</span>,onContinue:<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >t</span>his.dispatch({type:"continue"})}</span>,retry:c.options.retry,retryDelay:c.options.retryDelay,networkMode:c.options.networkMode}),this.promise=this.retryer.promise,this.promise}<span class="fstat-no" title="function not covered" ></span>dispatch(t</span>){<span class="cstat-no" title="statement not covered" >this.state=(<span class="fstat-no" title="function not covered" >e=&gt;{v</span>ar i,s;<span class="cstat-no" title="statement not covered" >switch(t.type){case"failed":<span class="cstat-no" title="statement not covered" >return{...e,fetchFailureCount:t.failureCount,fetchFailureReason:t.error};c</span>ase"pause":<span class="cstat-no" title="statement not covered" >return{...e,fetchStatus:"paused"};c</span>ase"continue":<span class="cstat-no" title="statement not covered" >return{...e,fetchStatus:"fetching"};c</span>ase"fetch":<span class="cstat-no" title="statement not covered" >return{...e,fetchFailureCount:0,fetchFailureReason:null,fetchMeta:null!=(i=t.meta)?i:null,fetchStatus:(0,u.Kw)(this.options.networkMode)?"fetching":"paused",...!e.dataUpdatedAt&amp;&amp;{error:null,status:"loading"}};c</span>ase"success":<span class="cstat-no" title="statement not covered" >return{...e,data:t.data,dataUpdateCount:e.dataUpdateCount+1,dataUpdatedAt:null!=(s=t.dataUpdatedAt)?s:Date.now(),error:null,isInvalidated:!1,status:"success",...!t.manual&amp;&amp;{fetchStatus:"idle",fetchFailureCount:0,fetchFailureReason:null}};c</span>ase"error":let r=<span class="cstat-no" title="statement not covered" >t.error;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f((0,u.DV)(r)&amp;&amp;r.revert&amp;&amp;this.revertState)<span class="cstat-no" title="statement not covered" >return{...this.revertState};<span class="cstat-no" title="statement not covered" >r</span></span>eturn{...e,error:r,errorUpdateCount:e.errorUpdateCount+1,errorUpdatedAt:Date.now(),fetchFailureCount:e.fetchFailureCount+1,fetchFailureReason:r,fetchStatus:"idle",status:"error"};c</span>ase"invalidate":<span class="cstat-no" title="statement not covered" >return{...e,isInvalidated:!0};c</span>ase"setState":<span class="cstat-no" title="statement not covered" >return{...e,...t.state}}</span>}</span>)(this.state),a.V.batch(<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >t</span>his.observers.forEach(<span class="fstat-no" title="function not covered" >e=&gt;{<span class="cstat-no" title="statement not covered" >e</span>.onQueryUpdate(t)}</span>),this.cache.notify({query:this,type:"updated",action:t})}</span>)}</span>}var l=<span class="cstat-no" title="statement not covered" >i(3131);c</span>lass c extends l.l{<span class="fstat-no" title="function not covered" >constructor(t</span>){<span class="cstat-no" title="statement not covered" >super(),this.config=t||{},this.queries=[],this.queriesMap={}}<span class="fstat-no" title="function not covered" ></span>build(t</span>,e,i){var s;let n=<span class="cstat-no" title="statement not covered" >e.queryKey,a</span>=<span class="cstat-no" title="statement not covered" >null!=(s=e.queryHash)?s:(0,r.Rm)(n,e),u</span>=<span class="cstat-no" title="statement not covered" >this.get(a);<span class="cstat-no" title="statement not covered" >r</span>eturn u||(u=new h({cache:this,logger:t.getLogger(),queryKey:n,queryHash:a,options:t.defaultQueryOptions(e),state:i,defaultOptions:t.getQueryDefaults(n)}),this.add(u)),u}<span class="fstat-no" title="function not covered" ></span>add(t</span>){<span class="cstat-no" title="statement not covered" >this.queriesMap[t.queryHash]||(this.queriesMap[t.queryHash]=t,this.queries.push(t),this.notify({type:"added",query:t}))}<span class="fstat-no" title="function not covered" ></span>remove(t</span>){let e=<span class="cstat-no" title="statement not covered" >this.queriesMap[t.queryHash];<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;(t.destroy(),this.queries=this.queries.filter(<span class="fstat-no" title="function not covered" >e=&gt;<span class="cstat-no" title="statement not covered" >e</span>!==t),e</span>===t&amp;&amp;delete this.queriesMap[t.queryHash],this.notify({type:"removed",query:t}))}<span class="fstat-no" title="function not covered" ></span>clear(){<span class="cstat-no" title="statement not covered" ></span>a.V.batch(<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >t</span>his.queries.forEach(<span class="fstat-no" title="function not covered" >t=&gt;{<span class="cstat-no" title="statement not covered" >t</span>his.remove(t)}</span>)}</span>)}<span class="fstat-no" title="function not covered" ></span>get(t</span>){<span class="cstat-no" title="statement not covered" >return this.queriesMap[t]}<span class="fstat-no" title="function not covered" >g</span>etAll(){<span class="cstat-no" title="statement not covered" ></span>return this.queries}<span class="fstat-no" title="function not covered" ></span>find(t</span>,e){let[i]=<span class="cstat-no" title="statement not covered" >(0,r.I6)(t,e);<span class="cstat-no" title="statement not covered" >r</span>eturn void 0===i.exact&amp;&amp;(i.exact=!0),this.queries.find(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >(</span>0,r._x)(i,t))}<span class="fstat-no" title="function not covered" ></span></span>findAll(t</span>,e){let[i]=<span class="cstat-no" title="statement not covered" >(0,r.I6)(t,e);<span class="cstat-no" title="statement not covered" >r</span>eturn Object.keys(i).length&gt;0?this.queries.filter(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >(</span>0,r._x)(i,t)):t</span>his.queries}<span class="fstat-no" title="function not covered" ></span>notify(t</span>){<span class="cstat-no" title="statement not covered" >a.V.batch(<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >t</span>his.listeners.forEach(<span class="fstat-no" title="function not covered" >({</span>listener:e})=&gt;{<span class="cstat-no" title="statement not covered" >e(t)}</span>)}</span>)}<span class="fstat-no" title="function not covered" ></span>onFocus(){<span class="cstat-no" title="statement not covered" ></span>a.V.batch(<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >t</span>his.queries.forEach(<span class="fstat-no" title="function not covered" >t=&gt;{<span class="cstat-no" title="statement not covered" >t</span>.onFocus()}</span>)}</span>)}<span class="fstat-no" title="function not covered" ></span>onOnline(){<span class="cstat-no" title="statement not covered" ></span>a.V.batch(<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >t</span>his.queries.forEach(<span class="fstat-no" title="function not covered" >t=&gt;{<span class="cstat-no" title="statement not covered" >t</span>.onOnline()}</span>)}</span>)}</span>}var d=<span class="cstat-no" title="statement not covered" >i(4648);c</span>lass f extends l.l{<span class="fstat-no" title="function not covered" >constructor(t</span>){<span class="cstat-no" title="statement not covered" >super(),this.config=t||{},this.mutations=[],this.mutationId=0}<span class="fstat-no" title="function not covered" ></span>build(t</span>,e,i){let s=<span class="cstat-no" title="statement not covered" >new d.m({mutationCache:this,logger:t.getLogger(),mutationId:++this.mutationId,options:t.defaultMutationOptions(e),state:i,defaultOptions:e.mutationKey?t.getMutationDefaults(e.mutationKey):void 0});<span class="cstat-no" title="statement not covered" >r</span>eturn this.add(s),s}<span class="fstat-no" title="function not covered" ></span>add(t</span>){<span class="cstat-no" title="statement not covered" >this.mutations.push(t),this.notify({type:"added",mutation:t})}<span class="fstat-no" title="function not covered" ></span>remove(t</span>){<span class="cstat-no" title="statement not covered" >this.mutations=this.mutations.filter(<span class="fstat-no" title="function not covered" >e=&gt;<span class="cstat-no" title="statement not covered" >e</span>!==t),t</span>his.notify({type:"removed",mutation:t})}<span class="fstat-no" title="function not covered" ></span>clear(){<span class="cstat-no" title="statement not covered" ></span>a.V.batch(<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >t</span>his.mutations.forEach(<span class="fstat-no" title="function not covered" >t=&gt;{<span class="cstat-no" title="statement not covered" >t</span>his.remove(t)}</span>)}</span>)}<span class="fstat-no" title="function not covered" ></span>getAll(){<span class="cstat-no" title="statement not covered" ></span>return this.mutations}<span class="fstat-no" title="function not covered" ></span>find(t</span>){<span class="cstat-no" title="statement not covered" >return void 0===t.exact&amp;&amp;(t.exact=!0),this.mutations.find(<span class="fstat-no" title="function not covered" >e=&gt;<span class="cstat-no" title="statement not covered" >(</span>0,r.X7)(t,e))}<span class="fstat-no" title="function not covered" ></span></span>findAll(t</span>){<span class="cstat-no" title="statement not covered" >return this.mutations.filter(<span class="fstat-no" title="function not covered" >e=&gt;<span class="cstat-no" title="statement not covered" >(</span>0,r.X7)(t,e))}<span class="fstat-no" title="function not covered" ></span></span>notify(t</span>){<span class="cstat-no" title="statement not covered" >a.V.batch(<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >t</span>his.listeners.forEach(<span class="fstat-no" title="function not covered" >({</span>listener:e})=&gt;{<span class="cstat-no" title="statement not covered" >e(t)}</span>)}</span>)}<span class="fstat-no" title="function not covered" ></span>resumePausedMutations(){</span>var t;<span class="cstat-no" title="statement not covered" >return this.resuming=(null!=(t=this.resuming)?t:Promise.resolve()).then(<span class="fstat-no" title="function not covered" >()=&gt;{l</span>et t=<span class="cstat-no" title="statement not covered" >this.mutations.filter(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >t</span>.state.isPaused);<span class="cstat-no" title="statement not covered" >r</span></span>eturn a.V.batch(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >t</span>.reduce(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t.then(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >e</span>.continue().catch(r.ZT)),P</span></span>romise.resolve()))}</span></span>).then(<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >t</span>his.resuming=void 0}</span>),this.resuming}</span>}var y=<span class="cstat-no" title="statement not covered" >i(3908),p</span>=<span class="cstat-no" title="statement not covered" >i(8566),v</span>=<span class="cstat-no" title="statement not covered" >i(8326);c</span>lass m{<span class="fstat-no" title="function not covered" >constructor(t</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >this.queryCache=t.queryCache||new c,this.mutationCache=t.mutationCache||new f,this.logger=t.logger||n._,this.defaultOptions=t.defaultOptions||{},this.queryDefaults=[],this.mutationDefaults=[],this.mountCount=0}<span class="fstat-no" title="function not covered" ></span>mount(){<span class="cstat-no" title="statement not covered" ></span>this.mountCount++,1===this.mountCount&amp;&amp;(this.unsubscribeFocus=y.j.subscribe(<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >y</span>.j.isFocused()&amp;&amp;(this.resumePausedMutations(),this.queryCache.onFocus())}</span>),this.unsubscribeOnline=p.N.subscribe(<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >p</span>.N.isOnline()&amp;&amp;(this.resumePausedMutations(),this.queryCache.onOnline())}</span>))}<span class="fstat-no" title="function not covered" ></span>unmount(){</span>var t,e;<span class="cstat-no" title="statement not covered" >this.mountCount--,0===this.mountCount&amp;&amp;(null==(t=this.unsubscribeFocus)||t.call(this),this.unsubscribeFocus=void 0,null==(e=this.unsubscribeOnline)||e.call(this),this.unsubscribeOnline=void 0)}<span class="fstat-no" title="function not covered" ></span>isFetching(t</span>,e){let[i]=<span class="cstat-no" title="statement not covered" >(0,r.I6)(t,e);<span class="cstat-no" title="statement not covered" >r</span>eturn i.fetchStatus="fetching",this.queryCache.findAll(i).length}<span class="fstat-no" title="function not covered" ></span>isMutating(t</span>){<span class="cstat-no" title="statement not covered" >return this.mutationCache.findAll({...t,fetching:!0}).length}<span class="fstat-no" title="function not covered" ></span>getQueryData(t</span>,e){var i;<span class="cstat-no" title="statement not covered" >return null==(i=this.queryCache.find(t,e))?void 0:i.state.data}<span class="fstat-no" title="function not covered" ></span>ensureQueryData(t</span>,e,i){let s=<span class="cstat-no" title="statement not covered" >(0,r._v)(t,e,i),n</span>=<span class="cstat-no" title="statement not covered" >this.getQueryData(s.queryKey);<span class="cstat-no" title="statement not covered" >r</span>eturn n?Promise.resolve(n):this.fetchQuery(s)}<span class="fstat-no" title="function not covered" ></span>getQueriesData(t</span>){<span class="cstat-no" title="statement not covered" >return this.getQueryCache().findAll(t).map(<span class="fstat-no" title="function not covered" >({</span>queryKey:t,state:e})=&gt;{let i=<span class="cstat-no" title="statement not covered" >e.data;<span class="cstat-no" title="statement not covered" >r</span>eturn[t,i]})}<span class="fstat-no" title="function not covered" ></span></span>setQueryData(t</span>,e,i){let s=<span class="cstat-no" title="statement not covered" >this.queryCache.find(t),n</span>=<span class="cstat-no" title="statement not covered" >null==s?void 0:s.state.data,a</span>=<span class="cstat-no" title="statement not covered" >(0,r.SE)(e,n);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(void 0===a)<span class="cstat-no" title="statement not covered" >return;l</span></span>et u=<span class="cstat-no" title="statement not covered" >(0,r._v)(t),o</span>=<span class="cstat-no" title="statement not covered" >this.defaultQueryOptions(u);<span class="cstat-no" title="statement not covered" >r</span>eturn this.queryCache.build(this,o).setData(a,{...i,manual:!0})}<span class="fstat-no" title="function not covered" ></span>setQueriesData(t</span>,e,i){<span class="cstat-no" title="statement not covered" >return a.V.batch(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >t</span>his.getQueryCache().findAll(t).map(<span class="fstat-no" title="function not covered" >({</span>queryKey:t})=&gt;<span class="cstat-no" title="statement not covered" >[t,this.setQueryData(t,e,i)]))}<span class="fstat-no" title="function not covered" ></span></span></span>getQueryState(t</span>,e){var i;<span class="cstat-no" title="statement not covered" >return null==(i=this.queryCache.find(t,e))?void 0:i.state}<span class="fstat-no" title="function not covered" ></span>removeQueries(t</span>,e){let[i]=<span class="cstat-no" title="statement not covered" >(0,r.I6)(t,e),s</span>=<span class="cstat-no" title="statement not covered" >this.queryCache;<span class="cstat-no" title="statement not covered" >a</span>.V.batch(<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >s</span>.findAll(i).forEach(<span class="fstat-no" title="function not covered" >t=&gt;{<span class="cstat-no" title="statement not covered" >s</span>.remove(t)}</span>)}</span>)}<span class="fstat-no" title="function not covered" ></span>resetQueries(t</span>,e,i){let[s,n]=<span class="cstat-no" title="statement not covered" >(0,r.I6)(t,e,i),u</span>=<span class="cstat-no" title="statement not covered" >this.queryCache,o</span>=<span class="cstat-no" title="statement not covered" >{type:"active",...s};<span class="cstat-no" title="statement not covered" >r</span>eturn a.V.batch(<span class="fstat-no" title="function not covered" >()=&gt;(<span class="cstat-no" title="statement not covered" >u</span>.findAll(s).forEach(<span class="fstat-no" title="function not covered" >t=&gt;{<span class="cstat-no" title="statement not covered" >t</span>.reset()}</span>),this.refetchQueries(o,n)</span>))}<span class="fstat-no" title="function not covered" ></span>cancelQueries(t</span>,e,i){let[s,n=<span class="branch-0 cbranch-no" title="branch not covered" >{}]</span>=<span class="cstat-no" title="statement not covered" >(0,r.I6)(t,e,i);<span class="cstat-no" title="statement not covered" >v</span>oid 0===n.revert&amp;&amp;(n.revert=!0);l</span>et u=<span class="cstat-no" title="statement not covered" >a.V.batch(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >t</span>his.queryCache.findAll(s).map(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >t</span>.cancel(n)));<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn Promise.all(u).then(r.ZT).catch(r.ZT)}<span class="fstat-no" title="function not covered" ></span>invalidateQueries(t</span>,e,i){let[s,n]=<span class="cstat-no" title="statement not covered" >(0,r.I6)(t,e,i);<span class="cstat-no" title="statement not covered" >r</span>eturn a.V.batch(<span class="fstat-no" title="function not covered" >()=&gt;{v</span>ar t,e;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(this.queryCache.findAll(s).forEach(<span class="fstat-no" title="function not covered" >t=&gt;{<span class="cstat-no" title="statement not covered" >t</span>.invalidate()}</span>),"none"===s.refetchType)<span class="cstat-no" title="statement not covered" >return Promise.resolve();l</span></span>et i=<span class="cstat-no" title="statement not covered" >{...s,type:null!=(t=null!=(e=s.refetchType)?e:s.type)?t:"active"};<span class="cstat-no" title="statement not covered" >r</span>eturn this.refetchQueries(i,n)}</span>)}<span class="fstat-no" title="function not covered" ></span>refetchQueries(t</span>,e,i){let[s,n]=<span class="cstat-no" title="statement not covered" >(0,r.I6)(t,e,i),u</span>=<span class="cstat-no" title="statement not covered" >a.V.batch(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >t</span>his.queryCache.findAll(s).filter(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >!</span>t.isDisabled()).m</span>ap(<span class="fstat-no" title="function not covered" >t=&gt;{v</span>ar e;<span class="cstat-no" title="statement not covered" >return t.fetch(void 0,{...n,cancelRefetch:null==(e=null==n?void 0:n.cancelRefetch)||e,meta:{refetchPage:s.refetchPage}})}</span>)),o</span></span>=<span class="cstat-no" title="statement not covered" >Promise.all(u).then(r.ZT);<span class="cstat-no" title="statement not covered" >r</span>eturn null!=n&amp;&amp;n.throwOnError||(o=o.catch(r.ZT)),o}<span class="fstat-no" title="function not covered" ></span>fetchQuery(t</span>,e,i){let s=<span class="cstat-no" title="statement not covered" >(0,r._v)(t,e,i),n</span>=<span class="cstat-no" title="statement not covered" >this.defaultQueryOptions(s);<span class="cstat-no" title="statement not covered" >v</span>oid 0===n.retry&amp;&amp;(n.retry=!1);l</span>et a=<span class="cstat-no" title="statement not covered" >this.queryCache.build(this,n);<span class="cstat-no" title="statement not covered" >r</span>eturn a.isStaleByTime(n.staleTime)?a.fetch(n):Promise.resolve(a.state.data)}<span class="fstat-no" title="function not covered" ></span>prefetchQuery(t</span>,e,i){<span class="cstat-no" title="statement not covered" >return this.fetchQuery(t,e,i).then(r.ZT).catch(r.ZT)}<span class="fstat-no" title="function not covered" ></span>fetchInfiniteQuery(t</span>,e,i){let s=<span class="cstat-no" title="statement not covered" >(0,r._v)(t,e,i);<span class="cstat-no" title="statement not covered" >r</span>eturn s.behavior=(0,v.Gm)(),this.fetchQuery(s)}<span class="fstat-no" title="function not covered" ></span>prefetchInfiniteQuery(t</span>,e,i){<span class="cstat-no" title="statement not covered" >return this.fetchInfiniteQuery(t,e,i).then(r.ZT).catch(r.ZT)}<span class="fstat-no" title="function not covered" ></span>resumePausedMutations(){<span class="cstat-no" title="statement not covered" ></span>return this.mutationCache.resumePausedMutations()}<span class="fstat-no" title="function not covered" ></span>getQueryCache(){<span class="cstat-no" title="statement not covered" ></span>return this.queryCache}<span class="fstat-no" title="function not covered" ></span>getMutationCache(){<span class="cstat-no" title="statement not covered" ></span>return this.mutationCache}<span class="fstat-no" title="function not covered" ></span>getLogger(){<span class="cstat-no" title="statement not covered" ></span>return this.logger}<span class="fstat-no" title="function not covered" ></span>getDefaultOptions(){<span class="cstat-no" title="statement not covered" ></span>return this.defaultOptions}<span class="fstat-no" title="function not covered" ></span>setDefaultOptions(t</span>){<span class="cstat-no" title="statement not covered" >this.defaultOptions=t}<span class="fstat-no" title="function not covered" ></span>setQueryDefaults(t</span>,e){let i=<span class="cstat-no" title="statement not covered" >this.queryDefaults.find(<span class="fstat-no" title="function not covered" >e=&gt;<span class="cstat-no" title="statement not covered" >(</span>0,r.yF)(t)===(0,r.yF)(e.queryKey));<span class="cstat-no" title="statement not covered" >i</span></span>?i.defaultOptions=e:this.queryDefaults.push({queryKey:t,defaultOptions:e})}<span class="fstat-no" title="function not covered" ></span>getQueryDefaults(t</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!t)<span class="cstat-no" title="statement not covered" >return;l</span></span>et e=<span class="cstat-no" title="statement not covered" >this.queryDefaults.find(<span class="fstat-no" title="function not covered" >e=&gt;<span class="cstat-no" title="statement not covered" >(</span>0,r.to)(t,e.queryKey));<span class="cstat-no" title="statement not covered" >r</span></span>eturn null==e?void 0:e.defaultOptions}<span class="fstat-no" title="function not covered" ></span>setMutationDefaults(t</span>,e){let i=<span class="cstat-no" title="statement not covered" >this.mutationDefaults.find(<span class="fstat-no" title="function not covered" >e=&gt;<span class="cstat-no" title="statement not covered" >(</span>0,r.yF)(t)===(0,r.yF)(e.mutationKey));<span class="cstat-no" title="statement not covered" >i</span></span>?i.defaultOptions=e:this.mutationDefaults.push({mutationKey:t,defaultOptions:e})}<span class="fstat-no" title="function not covered" ></span>getMutationDefaults(t</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!t)<span class="cstat-no" title="statement not covered" >return;l</span></span>et e=<span class="cstat-no" title="statement not covered" >this.mutationDefaults.find(<span class="fstat-no" title="function not covered" >e=&gt;<span class="cstat-no" title="statement not covered" >(</span>0,r.to)(t,e.mutationKey));<span class="cstat-no" title="statement not covered" >r</span></span>eturn null==e?void 0:e.defaultOptions}<span class="fstat-no" title="function not covered" ></span>defaultQueryOptions(t</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(null!=t&amp;&amp;t._defaulted)<span class="cstat-no" title="statement not covered" >return t;l</span></span>et e=<span class="cstat-no" title="statement not covered" >{...this.defaultOptions.queries,...this.getQueryDefaults(null==t?void 0:t.queryKey),...t,_defaulted:!0};<span class="cstat-no" title="statement not covered" >r</span>eturn!e.queryHash&amp;&amp;e.queryKey&amp;&amp;(e.queryHash=(0,r.Rm)(e.queryKey,e)),void 0===e.refetchOnReconnect&amp;&amp;(e.refetchOnReconnect="always"!==e.networkMode),void 0===e.useErrorBoundary&amp;&amp;(e.useErrorBoundary=!!e.suspense),e}<span class="fstat-no" title="function not covered" ></span>defaultMutationOptions(t</span>){<span class="cstat-no" title="statement not covered" >return null!=t&amp;&amp;t._defaulted?t:{...this.defaultOptions.mutations,...this.getMutationDefaults(null==t?void 0:t.mutationKey),...t,_defaulted:!0}}<span class="fstat-no" title="function not covered" ></span>clear(){<span class="cstat-no" title="statement not covered" ></span>this.queryCache.clear(),this.mutationCache.clear()}</span>}var g=<span class="cstat-no" title="statement not covered" >i(6647);l</span>et b=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn null}</span>;v</span>ar q=<span class="cstat-no" title="statement not covered" >i(8896);f</span>unction <span class="fstat-no" title="function not covered" >O(t</span>){let{children:e}=<span class="cstat-no" title="statement not covered" >t,[</span>i]=<span class="cstat-no" title="statement not covered" >(0,q.useState)(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >n</span>ew m);<span class="cstat-no" title="statement not covered" >r</span></span>eturn i.setDefaultOptions({queries:{refetchOnMount:!1,refetchOnWindowFocus:!1,refetchOnReconnect:!1}}),(0,s.jsxs)(g.QueryClientProvider,{client:i,children:[e,(0,s.jsx)(b,{initialIsOpen:!1})]})}</span>},7366:<span class="fstat-no" title="function not covered" >function(){}</span>,6382:<span class="fstat-no" title="function not covered" >function(t</span>,e,i){"use strict";/**</span>
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var s=<span class="cstat-no" title="statement not covered" >i(8896),r</span>=<span class="cstat-no" title="statement not covered" >Symbol.for("react.element"),n</span>=<span class="cstat-no" title="statement not covered" >Symbol.for("react.fragment"),a</span>=<span class="cstat-no" title="statement not covered" >Object.prototype.hasOwnProperty,u</span>=<span class="cstat-no" title="statement not covered" >s.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,o</span>=<span class="cstat-no" title="statement not covered" >{key:!0,ref:!0,__self:!0,__source:!0};f</span>unction <span class="fstat-no" title="function not covered" >h(t</span>,e,i){var s,n=<span class="cstat-no" title="statement not covered" >{},h</span>=<span class="cstat-no" title="statement not covered" >null,l</span>=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" >f</span>or(s in void 0!==i&amp;&amp;(h=""+i),void 0!==e.key&amp;&amp;(h=""+e.key),void 0!==e.ref&amp;&amp;(l=e.ref),e)<span class="cstat-no" title="statement not covered" >a.call(e,s)&amp;&amp;!o.hasOwnProperty(s)&amp;&amp;(n[s]=e[s]</span></span>);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t&amp;&amp;t.defaultProps)<span class="cstat-no" title="statement not covered" >for(s in e=t.defaultProps)<span class="cstat-no" title="statement not covered" >void 0===n[s]&amp;&amp;(n[s]=e[s]</span></span></span>);<span class="cstat-no" title="statement not covered" >return{$$typeof:r,type:t,key:h,ref:l,props:n,_owner:u.current}}<span class="cstat-no" title="statement not covered" ></span>e.Fragment=n,e.jsx=h,e.jsxs=h}</span>,5862:<span class="fstat-no" title="function not covered" >function(t</span>,e,i){"use strict";<span class="cstat-no" title="statement not covered" >t.exports=i(6382)}</span>,8326:<span class="fstat-no" title="function not covered" >function(t</span>,e,i){"use strict";function <span class="fstat-no" title="function not covered" >s(){<span class="cstat-no" title="statement not covered" >r</span>eturn{onFetch:<span class="fstat-no" title="function not covered" >t=&gt;{<span class="cstat-no" title="statement not covered" >t</span>.fetchFn=<span class="fstat-no" title="function not covered" >()=&gt;{v</span>ar e,i,s,a,u,o;let h;let l=<span class="cstat-no" title="statement not covered" >null==(e=t.fetchOptions)?void 0:null==(i=e.meta)?void 0:i.refetchPage,c</span>=<span class="cstat-no" title="statement not covered" >null==(s=t.fetchOptions)?void 0:null==(a=s.meta)?void 0:a.fetchMore,d</span>=<span class="cstat-no" title="statement not covered" >null==c?void 0:c.pageParam,f</span>=<span class="cstat-no" title="statement not covered" >(null==c?void 0:c.direction)==="forward",y</span>=<span class="cstat-no" title="statement not covered" >(null==c?void 0:c.direction)==="backward",p</span>=<span class="cstat-no" title="statement not covered" >(null==(u=t.state.data)?void 0:u.pages)||[],</span>v=<span class="cstat-no" title="statement not covered" >(null==(o=t.state.data)?void 0:o.pageParams)||[],</span>m=<span class="cstat-no" title="statement not covered" >v,g</span>=<span class="cstat-no" title="statement not covered" >!1,b</span>=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=&gt;{<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(e,"signal",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >()=&gt;{v</span>ar e,i;<span class="cstat-no" title="statement not covered" >return null!=(e=t.signal)&amp;&amp;e.aborted?g=!0:null==(i=t.signal)||i.addEventListener("abort",<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >g</span>=!0}</span>),t.signal}</span>})}</span>,q</span>=<span class="cstat-no" title="statement not covered" >t.options.queryFn||(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >P</span>romise.reject("Missing queryFn for queryKey '"+t.options.queryHash+"'")</span>),O</span>=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,i,s)=&gt;(<span class="cstat-no" title="statement not covered" >m=s?[e,...m]:[...m,e],s?[i,...t]:[...t,i]</span></span>),C=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,i,s,r)=&gt;{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(g)<span class="cstat-no" title="statement not covered" >return Promise.reject("Cancelled");<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(void 0===s&amp;&amp;!i&amp;&amp;e.length)<span class="cstat-no" title="statement not covered" >return Promise.resolve(e);l</span></span>et n=<span class="cstat-no" title="statement not covered" >{queryKey:t.queryKey,pageParam:s,meta:t.options.meta};<span class="cstat-no" title="statement not covered" >b</span>(n);l</span>et a=<span class="cstat-no" title="statement not covered" >q(n),u</span>=<span class="cstat-no" title="statement not covered" >Promise.resolve(a).then(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >O</span>(e,s,t,r));<span class="cstat-no" title="statement not covered" >r</span></span>eturn u}</span>;<span class="cstat-no" title="statement not covered" >i</span>f(p.length){<span class="cstat-no" title="statement not covered" >if(f){let e=<span class="cstat-no" title="statement not covered" >void 0!==d,i</span>=<span class="cstat-no" title="statement not covered" >e?d:r(t.options,p);<span class="cstat-no" title="statement not covered" >h</span>=C(p,e,i)}</span>else <span class="cstat-no" title="statement not covered" >if(y){let e=<span class="cstat-no" title="statement not covered" >void 0!==d,i</span>=<span class="cstat-no" title="statement not covered" >e?d:n(t.options,p);<span class="cstat-no" title="statement not covered" >h</span>=C(p,e,i,!0)}</span>else{<span class="cstat-no" title="statement not covered" >m=[];l</span>et e=<span class="cstat-no" title="statement not covered" >void 0===t.options.getNextPageParam,i</span>=<span class="cstat-no" title="statement not covered" >!l||!p[0]||l(p[0],0,p);<span class="cstat-no" title="statement not covered" >h</span>=i?C([],e,v[0]):Promise.resolve(O([],v[0],p[0]));<span class="cstat-no" title="statement not covered" >f</span>or(let i=<span class="cstat-no" title="statement not covered" >1;i</span>&lt;p.length;i++)<span class="cstat-no" title="statement not covered" >h=h.then(<span class="fstat-no" title="function not covered" >s=&gt;{l</span>et n=<span class="cstat-no" title="statement not covered" >!l||!p[i]||l(p[i],i,p);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(n){let n=<span class="cstat-no" title="statement not covered" >e?v[i]:r(t.options,s);<span class="cstat-no" title="statement not covered" >r</span>eturn C(s,e,n)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn Promise.resolve(O(s,v[i],p[i]))}</span>)}</span></span>}</span></span>else <span class="cstat-no" title="statement not covered" >h=C([]);l</span></span>et P=<span class="cstat-no" title="statement not covered" >h.then(<span class="fstat-no" title="function not covered" >t=&gt;(<span class="cstat-no" title="statement not covered" >{</span>pages:t,pageParams:m}));<span class="cstat-no" title="statement not covered" >r</span></span>eturn P}</span>}</span>}}</span>function <span class="fstat-no" title="function not covered" >r(t</span>,e){<span class="cstat-no" title="statement not covered" >return null==t.getNextPageParam?void 0:t.getNextPageParam(e[e.length-1],e)}</span>function <span class="fstat-no" title="function not covered" >n(t</span>,e){<span class="cstat-no" title="statement not covered" >return null==t.getPreviousPageParam?void 0:t.getPreviousPageParam(e[0],e)}</span>function <span class="fstat-no" title="function not covered" >a(t</span>,e){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t.getNextPageParam&amp;&amp;Array.isArray(e)){let i=<span class="cstat-no" title="statement not covered" >r(t,e);<span class="cstat-no" title="statement not covered" >r</span>eturn null!=i&amp;&amp;!1!==i}</span>}</span>function <span class="fstat-no" title="function not covered" >u(t</span>,e){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t.getPreviousPageParam&amp;&amp;Array.isArray(e)){let i=<span class="cstat-no" title="statement not covered" >n(t,e);<span class="cstat-no" title="statement not covered" >r</span>eturn null!=i&amp;&amp;!1!==i}</span>}<span class="cstat-no" title="statement not covered" ></span>i.d(e,{Gm:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn s}</span>,Qy:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn a}</span>,ZF:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn u}</span>})}</span>},<span class="fstat-no" title="function not covered" >function(t</span>){<span class="cstat-no" title="statement not covered" >t.O(0,[628,728,311,744],<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn t(t.s=2376)}</span>),_N_E=t.O()}</span>]);</pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank" rel="noopener noreferrer">istanbul</a>
                at 2023-07-28T11:41:41.928Z
            </div>
        <script src="../../../../../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../../../../../sorter.js"></script>
        <script src="../../../../../block-navigation.js"></script>
    </body>
</html>
    