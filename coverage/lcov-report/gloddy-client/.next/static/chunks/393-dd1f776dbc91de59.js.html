
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for gloddy-client/.next/static/chunks/393-dd1f776dbc91de59.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../../../prettify.css" />
    <link rel="stylesheet" href="../../../../base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="../../../../favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../../../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../../../../index.html">All files</a> / <a href="index.html">gloddy-client/.next/static/chunks</a> 393-dd1f776dbc91de59.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>0/585</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>0/481</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>0/241</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>0/2</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
        <template id="filterTemplate">
            <div class="quiet">
                Filter:
                <input oninput="onInput()" type="search" id="fileSearch">
            </div>
        </template>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a>
<a name='L4'></a><a href='#L4'>4</a>
<a name='L5'></a><a href='#L5'>5</a>
<a name='L6'></a><a href='#L6'>6</a>
<a name='L7'></a><a href='#L7'>7</a>
<a name='L8'></a><a href='#L8'>8</a>
<a name='L9'></a><a href='#L9'>9</a></td><td class="line-coverage quiet"><span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">"use strict";(<span class="cstat-no" title="statement not covered" >self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[393],{1906:<span class="fstat-no" title="function not covered" >function(t</span>,e,r){<span class="cstat-no" title="statement not covered" >r.d(e,{SV:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn u}</span>});v</span>ar s=<span class="cstat-no" title="statement not covered" >r(8896);l</span>et i=<span class="cstat-no" title="statement not covered" >(0,s.createContext)(null),n</span>=<span class="cstat-no" title="statement not covered" >{didCatch:!1,error:null};c</span>lass u extends s.Component{<span class="fstat-no" title="function not covered" >constructor(t</span>){<span class="cstat-no" title="statement not covered" >super(t),this.resetErrorBoundary=this.resetErrorBoundary.bind(this),this.state=n}<span class="fstat-no" title="function not covered" ></span>static g</span>etDerivedStateFromError(t){<span class="cstat-no" title="statement not covered" >return{didCatch:!0,error:t}}<span class="fstat-no" title="function not covered" ></span>resetErrorBoundary(){</span>let{error:t}=<span class="cstat-no" title="statement not covered" >this.state;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(null!==t){<span class="cstat-no" title="statement not covered" >for(var e,r,s=<span class="cstat-no" title="statement not covered" >arguments.length,i</span>=<span class="cstat-no" title="statement not covered" >Array(s),u</span>=<span class="cstat-no" title="statement not covered" >0;u</span>&lt;s;u++)<span class="cstat-no" title="statement not covered" >i[u]=arguments[u];<span class="cstat-no" title="statement not covered" >n</span></span>ull===(e=(r=this.props).onReset)||void 0===e||e.call(r,{args:i,reason:"imperative-api"}),this.setState(n)}</span>}<span class="fstat-no" title="function not covered" ></span>componentDidCatch(t</span>,e){var r,s;<span class="cstat-no" title="statement not covered" >null===(r=(s=this.props).onError)||void 0===r||r.call(s,t,e)}<span class="fstat-no" title="function not covered" ></span>componentDidUpdate(t</span>,e){let{didCatch:r}=<span class="cstat-no" title="statement not covered" >this.state,{</span>resetKeys:s}=<span class="cstat-no" title="statement not covered" >this.props;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(r&amp;&amp;null!==e.error&amp;&amp;<span class="fstat-no" title="function not covered" >function(){l</span>et t=<span class="cstat-no" title="statement not covered" >arguments.length&gt;0&amp;&amp;void 0!==arguments[0]?arguments[0]:[],</span>e=<span class="cstat-no" title="statement not covered" >arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:[];<span class="cstat-no" title="statement not covered" ></span>return t.length!==e.length||t.some(<span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;<span class="cstat-no" title="statement not covered" >!Object.is(t,e[r]))}</span></span>(t.resetKeys,s)){var i,u;<span class="cstat-no" title="statement not covered" >null===(i=(u=this.props).onReset)||void 0===i||i.call(u,{next:s,prev:t.resetKeys,reason:"keys"}),this.setState(n)}</span>}<span class="fstat-no" title="function not covered" ></span>render(){</span>let{children:t,fallbackRender:e,FallbackComponent:r,fallback:n}=<span class="cstat-no" title="statement not covered" >this.props,{</span>didCatch:u,error:o}=<span class="cstat-no" title="statement not covered" >this.state,a</span>=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(u){let t=<span class="cstat-no" title="statement not covered" >{error:o,resetErrorBoundary:this.resetErrorBoundary};<span class="cstat-no" title="statement not covered" >i</span>f((0,s.isValidElement)(n))<span class="cstat-no" title="statement not covered" >a=n;else <span class="cstat-no" title="statement not covered" >i</span>f("function"==typeof e)<span class="cstat-no" title="statement not covered" >a=e(t);else <span class="cstat-no" title="statement not covered" >i</span>f(r)<span class="cstat-no" title="statement not covered" >a=(0,s.createElement)(r,t);else <span class="cstat-no" title="statement not covered" >t</span>hrow Error("react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop")}<span class="cstat-no" title="statement not covered" ></span></span></span></span>r</span>eturn(0,s.createElement)(i.Provider,{value:{didCatch:u,error:o,resetErrorBoundary:this.resetErrorBoundary}},a)}</span>}},9472:<span class="fstat-no" title="function not covered" >function(t</span>,e,r){/**</span>
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var s=<span class="cstat-no" title="statement not covered" >r(8896),i</span>=<span class="cstat-no" title="statement not covered" >"function"==typeof Object.is?Object.is:<span class="fstat-no" title="function not covered" >function(t</span>,e){<span class="cstat-no" title="statement not covered" >return t===e&amp;&amp;(0!==t||1/t==1/e)||t!=t&amp;&amp;e!=e}</span>,n</span>=<span class="cstat-no" title="statement not covered" >s.useState,u</span>=<span class="cstat-no" title="statement not covered" >s.useEffect,o</span>=<span class="cstat-no" title="statement not covered" >s.useLayoutEffect,a</span>=<span class="cstat-no" title="statement not covered" >s.useDebugValue;f</span>unction <span class="fstat-no" title="function not covered" >l(t</span>){var e=<span class="cstat-no" title="statement not covered" >t.getSnapshot;<span class="cstat-no" title="statement not covered" >t</span>=t.value;<span class="cstat-no" title="statement not covered" >t</span>ry{var r=<span class="cstat-no" title="statement not covered" >e();<span class="cstat-no" title="statement not covered" >r</span>eturn!i(t,r)}</span>catch(t){<span class="cstat-no" title="statement not covered" >return!0}</span>}</span>var c=<span class="cstat-no" title="statement not covered" >"undefined"==typeof window||void 0===window.document||void 0===window.document.createElement?<span class="fstat-no" title="function not covered" >function(t</span>,e){<span class="cstat-no" title="statement not covered" >return e()}</span>:<span class="fstat-no" title="function not covered" >function(t</span>,e){var r=<span class="cstat-no" title="statement not covered" >e(),s</span>=<span class="cstat-no" title="statement not covered" >n({inst:{value:r,getSnapshot:e}}),i</span>=<span class="cstat-no" title="statement not covered" >s[0].inst,c</span>=<span class="cstat-no" title="statement not covered" >s[1];<span class="cstat-no" title="statement not covered" ></span>return o(<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >i</span>.value=r,i.getSnapshot=e,l(i)&amp;&amp;c({inst:i})}</span>,[t,r,e]),u(<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn l(i)&amp;&amp;c({inst:i}),t(<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >l</span>(i)&amp;&amp;c({inst:i})}</span>)}</span>,[t]),a(r),r}</span>;<span class="cstat-no" title="statement not covered" >e</span>.useSyncExternalStore=void 0!==s.useSyncExternalStore?s.useSyncExternalStore:c}</span>,8347:<span class="fstat-no" title="function not covered" >function(t</span>,e,r){<span class="cstat-no" title="statement not covered" >t.exports=r(9472)}</span>,8576:<span class="fstat-no" title="function not covered" >function(t</span>,e,r){<span class="cstat-no" title="statement not covered" >r.r(e),r.d(e,{Hydrate:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn u}</span>,useHydrate:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn n}</span>});v</span>ar s=<span class="cstat-no" title="statement not covered" >r(8896),i</span>=<span class="cstat-no" title="statement not covered" >r(6647);f</span>unction <span class="fstat-no" title="function not covered" >n(t</span>,e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{let r=<span class="cstat-no" title="statement not covered" >(0,i.useQueryClient)({context:e.context}),n</span>=<span class="cstat-no" title="statement not covered" >s.useRef(e);<span class="cstat-no" title="statement not covered" >n</span>.current=e,s.useMemo(<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >t</span>&amp;&amp;<span class="fstat-no" title="function not covered" >function(t</span>,e,r){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if("object"!=typeof e||null===e)<span class="cstat-no" title="statement not covered" >return;l</span></span>et s=<span class="cstat-no" title="statement not covered" >t.getMutationCache(),i</span>=<span class="cstat-no" title="statement not covered" >t.getQueryCache(),n</span>=<span class="cstat-no" title="statement not covered" >e.mutations||[],</span>u=<span class="cstat-no" title="statement not covered" >e.queries||[];<span class="cstat-no" title="statement not covered" ></span>n.forEach(<span class="fstat-no" title="function not covered" >e=&gt;{v</span>ar i;<span class="cstat-no" title="statement not covered" >s.build(t,{...null==r?void 0:null==(i=r.defaultOptions)?void 0:i.mutations,mutationKey:e.mutationKey},e.state)}</span>),u.forEach(<span class="fstat-no" title="function not covered" >e=&gt;{v</span>ar s;let n=<span class="cstat-no" title="statement not covered" >i.get(e.queryHash),u</span>=<span class="cstat-no" title="statement not covered" >{...e.state,fetchStatus:"idle"};<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(n){<span class="cstat-no" title="statement not covered" >n.state.dataUpdatedAt&lt;u.dataUpdatedAt&amp;&amp;n.setState(u);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>i</span>.build(t,{...null==r?void 0:null==(s=r.defaultOptions)?void 0:s.queries,queryKey:e.queryKey,queryHash:e.queryHash},u)}</span>)}</span>(r,t,n.current)}</span>,[r,t])}</span>let u=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>children:t,options:e,state:r})=&gt;(<span class="cstat-no" title="statement not covered" >n(r,e),t)}</span></span>,1298:<span class="fstat-no" title="function not covered" >function(t</span>,e,r){<span class="cstat-no" title="statement not covered" >r.r(e),r.d(e,{QueryErrorResetBoundary:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn o}</span>,useQueryErrorResetBoundary:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn u}</span>});v</span>ar s=<span class="cstat-no" title="statement not covered" >r(8896);f</span>unction <span class="fstat-no" title="function not covered" >i(){l</span>et t=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" >r</span>eturn{clearReset:<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >t</span>=!1}</span>,reset:<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >t</span>=!0}</span>,isReset:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >t</span>}</span>}</span>let n=<span class="cstat-no" title="statement not covered" >s.createContext(i()),u</span>=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >s</span>.useContext(n),o</span></span>=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>children:t})=&gt;{let[e]=<span class="cstat-no" title="statement not covered" >s.useState(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >i</span>());<span class="cstat-no" title="statement not covered" >r</span></span>eturn s.createElement(n.Provider,{value:e},"function"==typeof t?t(e):t)}</span>}</span>,2166:<span class="fstat-no" title="function not covered" >function(t</span>,e,r){<span class="cstat-no" title="statement not covered" >r.d(e,{JN:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn u}</span>,KJ:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn o}</span>,pf:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn n}</span>});v</span>ar s=<span class="cstat-no" title="statement not covered" >r(8896),i</span>=<span class="cstat-no" title="statement not covered" >r(5383);l</span>et n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{(<span class="cstat-no" title="statement not covered" >t.suspense||t.useErrorBoundary)&amp;&amp;!e.isReset()&amp;&amp;(t.retryOnMount=!1)}</span>,u</span>=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=&gt;{<span class="cstat-no" title="statement not covered" >s</span>.useEffect(<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >t</span>.clearReset()}</span>,[t])}</span>,o</span>=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>result:t,errorResetBoundary:e,useErrorBoundary:r,query:s})=&gt;<span class="cstat-no" title="statement not covered" >t.isError&amp;&amp;!e.isReset()&amp;&amp;!t.isFetching&amp;&amp;(0,i.L)(r,[t.error,s])}</span></span>,8547:<span class="fstat-no" title="function not covered" >function(t</span>,e,r){<span class="cstat-no" title="statement not covered" >r.r(e),r.d(e,{IsRestoringProvider:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn u}</span>,useIsRestoring:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn n}</span>});v</span>ar s=<span class="cstat-no" title="statement not covered" >r(8896);l</span>et i=<span class="cstat-no" title="statement not covered" >s.createContext(!1),n</span>=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >s</span>.useContext(i),u</span></span>=<span class="cstat-no" title="statement not covered" >i.Provider}</span>,9679:<span class="fstat-no" title="function not covered" >function(t</span>,e,r){<span class="cstat-no" title="statement not covered" >r.r(e),r.d(e,{unstable_batchedUpdates:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn i}</span>});v</span>ar s=<span class="cstat-no" title="statement not covered" >r(1210);l</span>et i=<span class="cstat-no" title="statement not covered" >s.unstable_batchedUpdates}</span>,1671:<span class="fstat-no" title="function not covered" >function(t</span>,e,r){<span class="cstat-no" title="statement not covered" >r.d(e,{Fb:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn s}</span>,SB:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn n}</span>,Z$:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn i}</span>,j8:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn u}</span>});l</span>et s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=&gt;{<span class="cstat-no" title="statement not covered" >t</span>.suspense&amp;&amp;"number"!=typeof t.staleTime&amp;&amp;(t.staleTime=1e3)}</span>,i</span>=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t.isLoading&amp;&amp;t.isFetching&amp;&amp;!e,n</span></span>=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,r)=&gt;<span class="cstat-no" title="statement not covered" >(null==t?void 0:t.suspense)&amp;&amp;i(e,r),u</span></span>=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,r)=&gt;<span class="cstat-no" title="statement not covered" >e.fetchOptimistic(t).then(<span class="fstat-no" title="function not covered" >({</span>data:e})=&gt;{<span class="cstat-no" title="statement not covered" >null==t.onSuccess||t.onSuccess(e),null==t.onSettled||t.onSettled(e,null)}</span>).catch(<span class="fstat-no" title="function not covered" >e=&gt;{<span class="cstat-no" title="statement not covered" >r</span>.clearReset(),null==t.onError||t.onError(e),null==t.onSettled||t.onSettled(void 0,e)}</span>)}</span></span>,3279:<span class="fstat-no" title="function not covered" >function(t</span>,e,r){<span class="cstat-no" title="statement not covered" >r.d(e,{r:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn h}</span>});v</span>ar s=<span class="cstat-no" title="statement not covered" >r(8896),i</span>=<span class="cstat-no" title="statement not covered" >r(4714),n</span>=<span class="cstat-no" title="statement not covered" >r(324),u</span>=<span class="cstat-no" title="statement not covered" >r(1298),o</span>=<span class="cstat-no" title="statement not covered" >r(6647),a</span>=<span class="cstat-no" title="statement not covered" >r(8547),l</span>=<span class="cstat-no" title="statement not covered" >r(2166),c</span>=<span class="cstat-no" title="statement not covered" >r(1671);f</span>unction <span class="fstat-no" title="function not covered" >h(t</span>,e){let r=<span class="cstat-no" title="statement not covered" >(0,o.useQueryClient)({context:t.context}),h</span>=<span class="cstat-no" title="statement not covered" >(0,a.useIsRestoring)(),d</span>=<span class="cstat-no" title="statement not covered" >(0,u.useQueryErrorResetBoundary)(),f</span>=<span class="cstat-no" title="statement not covered" >r.defaultQueryOptions(t);<span class="cstat-no" title="statement not covered" >f</span>._optimisticResults=h?"isRestoring":"optimistic",f.onError&amp;&amp;(f.onError=n.V.batchCalls(f.onError)),f.onSuccess&amp;&amp;(f.onSuccess=n.V.batchCalls(f.onSuccess)),f.onSettled&amp;&amp;(f.onSettled=n.V.batchCalls(f.onSettled)),(0,c.Fb)(f),(0,l.pf)(f,d),(0,l.JN)(d);l</span>et[p]=<span class="cstat-no" title="statement not covered" >s.useState(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >n</span>ew e(r,f)),v</span></span>=<span class="cstat-no" title="statement not covered" >p.getOptimisticResult(f);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f((0,i.$)(s.useCallback(<span class="fstat-no" title="function not covered" >t=&gt;{l</span>et e=<span class="cstat-no" title="statement not covered" >h?<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >v</span>oid 0:p</span>.subscribe(n.V.batchCalls(t));<span class="cstat-no" title="statement not covered" >r</span>eturn p.updateResult(),e}</span>,[p,h]),<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >p</span>.getCurrentResult(),<span class="fstat-no" title="function not covered" >(</span>)=&gt;<span class="cstat-no" title="statement not covered" >p</span>.getCurrentResult()),s</span>.useEffect(<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >p</span>.setOptions(f,{listeners:!1})}</span>,[f,p]),(0,c.SB)(f,v,h))<span class="cstat-no" title="statement not covered" >throw(0,c.j8)(f,p,d);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f((0,l.KJ)({result:v,errorResetBoundary:d,useErrorBoundary:f.useErrorBoundary,query:p.getCurrentQuery()}))<span class="cstat-no" title="statement not covered" >throw v.error;<span class="cstat-no" title="statement not covered" >r</span></span>eturn f.notifyOnChangeProps?v:p.trackResult(v)}</span>},7943:<span class="fstat-no" title="function not covered" >function(t</span>,e,r){<span class="cstat-no" title="statement not covered" >r.r(e),r.d(e,{useInfiniteQuery:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn a}</span>});v</span>ar s=<span class="cstat-no" title="statement not covered" >r(3199),i</span>=<span class="cstat-no" title="statement not covered" >r(1091),n</span>=<span class="cstat-no" title="statement not covered" >r(8326);c</span>lass u extends i.z{<span class="fstat-no" title="function not covered" >constructor(t</span>,e){<span class="cstat-no" title="statement not covered" >super(t,e)}<span class="fstat-no" title="function not covered" ></span>bindMethods(){<span class="cstat-no" title="statement not covered" ></span>super.bindMethods(),this.fetchNextPage=this.fetchNextPage.bind(this),this.fetchPreviousPage=this.fetchPreviousPage.bind(this)}<span class="fstat-no" title="function not covered" ></span>setOptions(t</span>,e){<span class="cstat-no" title="statement not covered" >super.setOptions({...t,behavior:(0,n.Gm)()},e)}<span class="fstat-no" title="function not covered" ></span>getOptimisticResult(t</span>){<span class="cstat-no" title="statement not covered" >return t.behavior=(0,n.Gm)(),super.getOptimisticResult(t)}<span class="fstat-no" title="function not covered" ></span>fetchNextPage({</span>pageParam:t,...e}=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return this.fetch({...e,meta:{fetchMore:{direction:"forward",pageParam:t}}})}<span class="fstat-no" title="function not covered" ></span>fetchPreviousPage({</span>pageParam:t,...e}=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return this.fetch({...e,meta:{fetchMore:{direction:"backward",pageParam:t}}})}<span class="fstat-no" title="function not covered" ></span>createResult(t</span>,e){var r,s,i,u,o,a;let{state:l}=<span class="cstat-no" title="statement not covered" >t,c</span>=<span class="cstat-no" title="statement not covered" >super.createResult(t,e),{</span>isFetching:h,isRefetching:d}=<span class="cstat-no" title="statement not covered" >c,f</span>=<span class="cstat-no" title="statement not covered" >h&amp;&amp;(null==(r=l.fetchMeta)?void 0:null==(s=r.fetchMore)?void 0:s.direction)==="forward",p</span>=<span class="cstat-no" title="statement not covered" >h&amp;&amp;(null==(i=l.fetchMeta)?void 0:null==(u=i.fetchMore)?void 0:u.direction)==="backward";<span class="cstat-no" title="statement not covered" >r</span>eturn{...c,fetchNextPage:this.fetchNextPage,fetchPreviousPage:this.fetchPreviousPage,hasNextPage:(0,n.Qy)(e,null==(o=l.data)?void 0:o.pages),hasPreviousPage:(0,n.ZF)(e,null==(a=l.data)?void 0:a.pages),isFetchingNextPage:f,isFetchingPreviousPage:p,isRefetching:d&amp;&amp;!f&amp;&amp;!p}}</span>}var o=<span class="cstat-no" title="statement not covered" >r(3279);f</span>unction <span class="fstat-no" title="function not covered" >a(t</span>,e,r){let i=<span class="cstat-no" title="statement not covered" >(0,s._v)(t,e,r);<span class="cstat-no" title="statement not covered" >r</span>eturn(0,o.r)(i,u)}</span>},3939:<span class="fstat-no" title="function not covered" >function(t</span>,e,r){<span class="cstat-no" title="statement not covered" >r.r(e),r.d(e,{useIsFetching:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn a}</span>});v</span>ar s=<span class="cstat-no" title="statement not covered" >r(8896),i</span>=<span class="cstat-no" title="statement not covered" >r(3199),n</span>=<span class="cstat-no" title="statement not covered" >r(324),u</span>=<span class="cstat-no" title="statement not covered" >r(4714),o</span>=<span class="cstat-no" title="statement not covered" >r(6647);f</span>unction <span class="fstat-no" title="function not covered" >a(t</span>,e,r){let[a,l=<span class="branch-0 cbranch-no" title="branch not covered" >{}]</span>=<span class="cstat-no" title="statement not covered" >(0,i.I6)(t,e,r),c</span>=<span class="cstat-no" title="statement not covered" >(0,o.useQueryClient)({context:l.context}),h</span>=<span class="cstat-no" title="statement not covered" >c.getQueryCache();<span class="cstat-no" title="statement not covered" >r</span>eturn(0,u.$)(s.useCallback(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >h</span>.subscribe(n.V.batchCalls(t)),[</span>h]),<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >c</span>.isFetching(a),<span class="fstat-no" title="function not covered" >(</span>)=&gt;<span class="cstat-no" title="statement not covered" >c</span>.isFetching(a))}</span></span>},7671:<span class="fstat-no" title="function not covered" >function(t</span>,e,r){<span class="cstat-no" title="statement not covered" >r.r(e),r.d(e,{useIsMutating:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn a}</span>});v</span>ar s=<span class="cstat-no" title="statement not covered" >r(8896),i</span>=<span class="cstat-no" title="statement not covered" >r(4714),n</span>=<span class="cstat-no" title="statement not covered" >r(3199),u</span>=<span class="cstat-no" title="statement not covered" >r(324),o</span>=<span class="cstat-no" title="statement not covered" >r(6647);f</span>unction <span class="fstat-no" title="function not covered" >a(t</span>,e,r){let[a,l=<span class="branch-0 cbranch-no" title="branch not covered" >{}]</span>=<span class="cstat-no" title="statement not covered" >(0,n.cb)(t,e,r),c</span>=<span class="cstat-no" title="statement not covered" >(0,o.useQueryClient)({context:l.context}),h</span>=<span class="cstat-no" title="statement not covered" >c.getMutationCache();<span class="cstat-no" title="statement not covered" >r</span>eturn(0,i.$)(s.useCallback(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >h</span>.subscribe(u.V.batchCalls(t)),[</span>h]),<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >c</span>.isMutating(a),<span class="fstat-no" title="function not covered" >(</span>)=&gt;<span class="cstat-no" title="statement not covered" >c</span>.isMutating(a))}</span></span>},2288:<span class="fstat-no" title="function not covered" >function(t</span>,e,r){<span class="cstat-no" title="statement not covered" >r.r(e),r.d(e,{useMutation:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn d}</span>});v</span>ar s=<span class="cstat-no" title="statement not covered" >r(8896),i</span>=<span class="cstat-no" title="statement not covered" >r(4714),n</span>=<span class="cstat-no" title="statement not covered" >r(3199),u</span>=<span class="cstat-no" title="statement not covered" >r(4648),o</span>=<span class="cstat-no" title="statement not covered" >r(324),a</span>=<span class="cstat-no" title="statement not covered" >r(3131);c</span>lass l extends a.l{<span class="fstat-no" title="function not covered" >constructor(t</span>,e){<span class="cstat-no" title="statement not covered" >super(),this.client=t,this.setOptions(e),this.bindMethods(),this.updateResult()}<span class="fstat-no" title="function not covered" ></span>bindMethods(){<span class="cstat-no" title="statement not covered" ></span>this.mutate=this.mutate.bind(this),this.reset=this.reset.bind(this)}<span class="fstat-no" title="function not covered" ></span>setOptions(t</span>){var e;let r=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" >t</span>his.options=this.client.defaultMutationOptions(t),(0,n.VS)(r,this.options)||this.client.getMutationCache().notify({type:"observerOptionsUpdated",mutation:this.currentMutation,observer:this}),null==(e=this.currentMutation)||e.setOptions(this.options)}<span class="fstat-no" title="function not covered" ></span>onUnsubscribe(){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(!this.hasListeners()){var t;<span class="cstat-no" title="statement not covered" >null==(t=this.currentMutation)||t.removeObserver(this)}</span>}<span class="fstat-no" title="function not covered" ></span>onMutationUpdate(t</span>){<span class="cstat-no" title="statement not covered" >this.updateResult();l</span>et e=<span class="cstat-no" title="statement not covered" >{listeners:!0};<span class="cstat-no" title="statement not covered" >"</span>success"===t.type?e.onSuccess=!0:"error"===t.type&amp;&amp;(e.onError=!0),this.notify(e)}<span class="fstat-no" title="function not covered" ></span>getCurrentResult(){<span class="cstat-no" title="statement not covered" ></span>return this.currentResult}<span class="fstat-no" title="function not covered" ></span>reset(){<span class="cstat-no" title="statement not covered" ></span>this.currentMutation=void 0,this.updateResult(),this.notify({listeners:!0})}<span class="fstat-no" title="function not covered" ></span>mutate(t</span>,e){<span class="cstat-no" title="statement not covered" >return this.mutateOptions=e,this.currentMutation&amp;&amp;this.currentMutation.removeObserver(this),this.currentMutation=this.client.getMutationCache().build(this.client,{...this.options,variables:void 0!==t?t:this.options.variables}),this.currentMutation.addObserver(this),this.currentMutation.execute()}<span class="fstat-no" title="function not covered" ></span>updateResult(){</span>let t=<span class="cstat-no" title="statement not covered" >this.currentMutation?this.currentMutation.state:(0,u.R)(),e</span>=<span class="cstat-no" title="statement not covered" >{...t,isLoading:"loading"===t.status,isSuccess:"success"===t.status,isError:"error"===t.status,isIdle:"idle"===t.status,mutate:this.mutate,reset:this.reset};<span class="cstat-no" title="statement not covered" >t</span>his.currentResult=e}<span class="fstat-no" title="function not covered" ></span>notify(t</span>){<span class="cstat-no" title="statement not covered" >o.V.batch(<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(this.mutateOptions&amp;&amp;this.hasListeners()){var e,r,s,i,n,u,o,a;<span class="cstat-no" title="statement not covered" >t.onSuccess?(null==(e=(r=this.mutateOptions).onSuccess)||e.call(r,this.currentResult.data,this.currentResult.variables,this.currentResult.context),null==(s=(i=this.mutateOptions).onSettled)||s.call(i,this.currentResult.data,null,this.currentResult.variables,this.currentResult.context)):t.onError&amp;&amp;(null==(n=(u=this.mutateOptions).onError)||n.call(u,this.currentResult.error,this.currentResult.variables,this.currentResult.context),null==(o=(a=this.mutateOptions).onSettled)||o.call(a,void 0,this.currentResult.error,this.currentResult.variables,this.currentResult.context))}<span class="cstat-no" title="statement not covered" ></span>t</span>.listeners&amp;&amp;this.listeners.forEach(<span class="fstat-no" title="function not covered" >({</span>listener:t})=&gt;{<span class="cstat-no" title="statement not covered" >t(this.currentResult)}</span>)}</span>)}</span>}var c=<span class="cstat-no" title="statement not covered" >r(6647),h</span>=<span class="cstat-no" title="statement not covered" >r(5383);f</span>unction <span class="fstat-no" title="function not covered" >d(t</span>,e,r){let u=<span class="cstat-no" title="statement not covered" >(0,n.lV)(t,e,r),a</span>=<span class="cstat-no" title="statement not covered" >(0,c.useQueryClient)({context:u.context}),[</span>d]=<span class="cstat-no" title="statement not covered" >s.useState(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >n</span>ew l(a,u));<span class="cstat-no" title="statement not covered" >s</span></span>.useEffect(<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >d</span>.setOptions(u)}</span>,[d,u]);l</span>et p=<span class="cstat-no" title="statement not covered" >(0,i.$)(s.useCallback(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >d</span>.subscribe(o.V.batchCalls(t)),[</span>d]),<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >d</span>.getCurrentResult(),<span class="fstat-no" title="function not covered" >(</span>)=&gt;<span class="cstat-no" title="statement not covered" >d</span>.getCurrentResult()),v</span></span>=<span class="cstat-no" title="statement not covered" >s.useCallback(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >d.mutate(t,e).catch(f)}</span>,[d]);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(p.error&amp;&amp;(0,h.L)(d.options.useErrorBoundary,[p.error]))<span class="cstat-no" title="statement not covered" >throw p.error;<span class="cstat-no" title="statement not covered" >r</span></span>eturn{...p,mutate:v,mutateAsync:p.mutate}}</span>function <span class="fstat-no" title="function not covered" >f(){}</span>},9513:<span class="fstat-no" title="function not covered" >function(t</span>,e,r){<span class="cstat-no" title="statement not covered" >r.r(e),r.d(e,{useQueries:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn v}</span>});v</span>ar s=<span class="cstat-no" title="statement not covered" >r(8896),i</span>=<span class="cstat-no" title="statement not covered" >r(4714),n</span>=<span class="cstat-no" title="statement not covered" >r(3199),u</span>=<span class="cstat-no" title="statement not covered" >r(324),o</span>=<span class="cstat-no" title="statement not covered" >r(1091),a</span>=<span class="cstat-no" title="statement not covered" >r(3131);c</span>lass l extends a.l{<span class="fstat-no" title="function not covered" >constructor(t</span>,e){<span class="cstat-no" title="statement not covered" >super(),this.client=t,this.queries=[],this.result=[],this.observers=[],this.observersMap={},e&amp;&amp;this.setQueries(e)}<span class="fstat-no" title="function not covered" ></span>onSubscribe(){<span class="cstat-no" title="statement not covered" ></span>1===this.listeners.size&amp;&amp;this.observers.forEach(<span class="fstat-no" title="function not covered" >t=&gt;{<span class="cstat-no" title="statement not covered" >t</span>.subscribe(<span class="fstat-no" title="function not covered" >e=&gt;{<span class="cstat-no" title="statement not covered" >t</span>his.onUpdate(t,e)}</span>)}</span>)}<span class="fstat-no" title="function not covered" ></span>onUnsubscribe(){<span class="cstat-no" title="statement not covered" ></span>this.listeners.size||this.destroy()}<span class="fstat-no" title="function not covered" ></span>destroy(){<span class="cstat-no" title="statement not covered" ></span>this.listeners=new Set,this.observers.forEach(<span class="fstat-no" title="function not covered" >t=&gt;{<span class="cstat-no" title="statement not covered" >t</span>.destroy()}</span>)}<span class="fstat-no" title="function not covered" ></span>setQueries(t</span>,e){<span class="cstat-no" title="statement not covered" >this.queries=t,u.V.batch(<span class="fstat-no" title="function not covered" >()=&gt;{l</span>et t=<span class="cstat-no" title="statement not covered" >this.observers,r</span>=<span class="cstat-no" title="statement not covered" >this.findMatchingObservers(this.queries);<span class="cstat-no" title="statement not covered" >r</span>.forEach(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >t</span>.observer.setOptions(t.defaultedQueryOptions,e));l</span></span>et s=<span class="cstat-no" title="statement not covered" >r.map(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >t</span>.observer),i</span></span>=<span class="cstat-no" title="statement not covered" >Object.fromEntries(s.map(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >[</span>t.options.queryHash,t])),u</span></span>=<span class="cstat-no" title="statement not covered" >s.map(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >t</span>.getCurrentResult()),o</span></span>=<span class="cstat-no" title="statement not covered" >s.some(<span class="fstat-no" title="function not covered" >(e</span>,r)=&gt;<span class="cstat-no" title="statement not covered" >e!==t[r])</span>;(<span class="cstat-no" title="statement not covered" >t</span>.length!==s.length||o)&amp;&amp;(this.observers=s,this.observersMap=i,this.result=u,this.hasListeners()&amp;&amp;((0,n.e5)(t,s).forEach(<span class="fstat-no" title="function not covered" >t=&gt;{<span class="cstat-no" title="statement not covered" >t</span>.destroy()}</span>),(0,n.e5)(s,t).forEach(<span class="fstat-no" title="function not covered" >t=&gt;{<span class="cstat-no" title="statement not covered" >t</span>.subscribe(<span class="fstat-no" title="function not covered" >e=&gt;{<span class="cstat-no" title="statement not covered" >t</span>his.onUpdate(t,e)}</span>)}</span>),this.notify()))}</span>)}<span class="fstat-no" title="function not covered" ></span>getCurrentResult(){<span class="cstat-no" title="statement not covered" ></span>return this.result}<span class="fstat-no" title="function not covered" ></span>getQueries(){<span class="cstat-no" title="statement not covered" ></span>return this.observers.map(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >t</span>.getCurrentQuery())}<span class="fstat-no" title="function not covered" ></span></span>getObservers(){<span class="cstat-no" title="statement not covered" ></span>return this.observers}<span class="fstat-no" title="function not covered" ></span>getOptimisticResult(t</span>){<span class="cstat-no" title="statement not covered" >return this.findMatchingObservers(t).map(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >t</span>.observer.getOptimisticResult(t.defaultedQueryOptions))}<span class="fstat-no" title="function not covered" ></span></span>findMatchingObservers(t</span>){let e=<span class="cstat-no" title="statement not covered" >this.observers,r</span>=<span class="cstat-no" title="statement not covered" >new Map(e.map(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >[</span>t.options.queryHash,t])),s</span></span>=<span class="cstat-no" title="statement not covered" >t.map(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >t</span>his.client.defaultQueryOptions(t)),i</span></span>=<span class="cstat-no" title="statement not covered" >s.flatMap(<span class="fstat-no" title="function not covered" >t=&gt;{l</span>et e=<span class="cstat-no" title="statement not covered" >r.get(t.queryHash);<span class="cstat-no" title="statement not covered" >r</span>eturn null!=e?[{defaultedQueryOptions:t,observer:e}]:[]}),n</span></span>=<span class="cstat-no" title="statement not covered" >new Set(i.map(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >t</span>.defaultedQueryOptions.queryHash)),u</span></span>=<span class="cstat-no" title="statement not covered" >s.filter(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >!</span>n.has(t.queryHash)),a</span></span>=<span class="cstat-no" title="statement not covered" >new Set(i.map(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >t</span>.observer)),l</span></span>=<span class="cstat-no" title="statement not covered" >e.filter(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >!</span>a.has(t)),c</span></span>=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=&gt;{l</span>et e=<span class="cstat-no" title="statement not covered" >this.client.defaultQueryOptions(t),r</span>=<span class="cstat-no" title="statement not covered" >this.observersMap[e.queryHash];<span class="cstat-no" title="statement not covered" ></span>return null!=r?r:new o.z(this.client,e)}</span>,h</span>=<span class="cstat-no" title="statement not covered" >u.map(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t.keepPreviousData){let r=<span class="cstat-no" title="statement not covered" >l[e];<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(void 0!==r)<span class="cstat-no" title="statement not covered" >return{defaultedQueryOptions:t,observer:r}}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn{defaultedQueryOptions:t,observer:c(t)}}</span>);<span class="cstat-no" title="statement not covered" >r</span>eturn i.concat(h).sort(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >s.indexOf(t.defaultedQueryOptions)-s.indexOf(e.defaultedQueryOptions))}<span class="fstat-no" title="function not covered" ></span></span>onUpdate(t</span>,e){let r=<span class="cstat-no" title="statement not covered" >this.observers.indexOf(t);<span class="cstat-no" title="statement not covered" >-</span>1!==r&amp;&amp;(this.result=(0,n.Rc)(this.result,r,e),this.notify())}<span class="fstat-no" title="function not covered" ></span>notify(){<span class="cstat-no" title="statement not covered" ></span>u.V.batch(<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >t</span>his.listeners.forEach(<span class="fstat-no" title="function not covered" >({</span>listener:t})=&gt;{<span class="cstat-no" title="statement not covered" >t(this.result)}</span>)}</span>)}</span>}var c=<span class="cstat-no" title="statement not covered" >r(6647),h</span>=<span class="cstat-no" title="statement not covered" >r(8547),d</span>=<span class="cstat-no" title="statement not covered" >r(1298),f</span>=<span class="cstat-no" title="statement not covered" >r(2166),p</span>=<span class="cstat-no" title="statement not covered" >r(1671);f</span>unction <span class="fstat-no" title="function not covered" >v({</span>queries:t,context:e}){let r=<span class="cstat-no" title="statement not covered" >(0,c.useQueryClient)({context:e}),n</span>=<span class="cstat-no" title="statement not covered" >(0,h.useIsRestoring)(),o</span>=<span class="cstat-no" title="statement not covered" >(0,d.useQueryErrorResetBoundary)(),a</span>=<span class="cstat-no" title="statement not covered" >s.useMemo(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >t</span>.map(<span class="fstat-no" title="function not covered" >t=&gt;{l</span>et e=<span class="cstat-no" title="statement not covered" >r.defaultQueryOptions(t);<span class="cstat-no" title="statement not covered" >r</span>eturn e._optimisticResults=n?"isRestoring":"optimistic",e}</span>),[</span>t,r,n]);<span class="cstat-no" title="statement not covered" >a</span>.forEach(<span class="fstat-no" title="function not covered" >t=&gt;{(<span class="cstat-no" title="statement not covered" >0</span>,p.Fb)(t),(0,f.pf)(t,o)}</span>),(0,f.JN)(o);l</span>et[v]=<span class="cstat-no" title="statement not covered" >s.useState(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >n</span>ew l(r,a)),y</span></span>=<span class="cstat-no" title="statement not covered" >v.getOptimisticResult(a);(<span class="cstat-no" title="statement not covered" >0</span>,i.$)(s.useCallback(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >n</span>?<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >v</span>oid 0:v</span>.subscribe(u.V.batchCalls(t)),[</span>v,n]),<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >v</span>.getCurrentResult(),<span class="fstat-no" title="function not covered" >(</span>)=&gt;<span class="cstat-no" title="statement not covered" >v</span>.getCurrentResult()),s</span>.useEffect(<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >v</span>.setQueries(a,{listeners:!1})}</span>,[a,v]);l</span>et b=<span class="cstat-no" title="statement not covered" >y.some(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >(0,p.SB)(a[e],t,n)),m</span></span>=<span class="cstat-no" title="statement not covered" >b?y.flatMap(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{let r=<span class="cstat-no" title="statement not covered" >a[e],</span>s=<span class="cstat-no" title="statement not covered" >v.getObservers()[e];<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(r&amp;&amp;s){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if((0,p.SB)(r,t,n))<span class="cstat-no" title="statement not covered" >return(0,p.j8)(r,s,o);(<span class="cstat-no" title="statement not covered" >0</span></span>,p.Z$)(t,n)&amp;&amp;(0,p.j8)(r,s,o)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn[]}):[</span>];<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(m.length&gt;0)<span class="cstat-no" title="statement not covered" >throw Promise.all(m);l</span></span>et g=<span class="cstat-no" title="statement not covered" >v.getQueries(),R</span>=<span class="cstat-no" title="statement not covered" >y.find(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{var r,s;<span class="cstat-no" title="statement not covered" >return(0,f.KJ)({result:t,errorResetBoundary:o,useErrorBoundary:null!=(r=null==(s=a[e])?void 0:s.useErrorBoundary)&amp;&amp;r,query:g[e]})}</span>);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(null!=R&amp;&amp;R.error)<span class="cstat-no" title="statement not covered" >throw R.error;<span class="cstat-no" title="statement not covered" >r</span></span>eturn y}</span>},3271:<span class="fstat-no" title="function not covered" >function(t</span>,e,r){<span class="cstat-no" title="statement not covered" >r.r(e),r.d(e,{useQuery:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn u}</span>});v</span>ar s=<span class="cstat-no" title="statement not covered" >r(3199),i</span>=<span class="cstat-no" title="statement not covered" >r(1091),n</span>=<span class="cstat-no" title="statement not covered" >r(3279);f</span>unction <span class="fstat-no" title="function not covered" >u(t</span>,e,r){let u=<span class="cstat-no" title="statement not covered" >(0,s._v)(t,e,r);<span class="cstat-no" title="statement not covered" >r</span>eturn(0,n.r)(u,i.z)}</span>},4714:<span class="fstat-no" title="function not covered" >function(t</span>,e,r){<span class="cstat-no" title="statement not covered" >r.d(e,{$:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn i}</span>});v</span>ar s=<span class="cstat-no" title="statement not covered" >r(8347);l</span>et i=<span class="cstat-no" title="statement not covered" >s.useSyncExternalStore}</span>,5383:<span class="fstat-no" title="function not covered" >function(t</span>,e,r){<span class="cstat-no" title="statement not covered" >r.d(e,{L:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn s}</span>});f</span>unction <span class="fstat-no" title="function not covered" >s(t</span>,e){<span class="cstat-no" title="statement not covered" >return"function"==typeof t?t(...e):!!t}</span>},8326:<span class="fstat-no" title="function not covered" >function(t</span>,e,r){function <span class="fstat-no" title="function not covered" >s(){<span class="cstat-no" title="statement not covered" >r</span>eturn{onFetch:<span class="fstat-no" title="function not covered" >t=&gt;{<span class="cstat-no" title="statement not covered" >t</span>.fetchFn=<span class="fstat-no" title="function not covered" >()=&gt;{v</span>ar e,r,s,u,o,a;let l;let c=<span class="cstat-no" title="statement not covered" >null==(e=t.fetchOptions)?void 0:null==(r=e.meta)?void 0:r.refetchPage,h</span>=<span class="cstat-no" title="statement not covered" >null==(s=t.fetchOptions)?void 0:null==(u=s.meta)?void 0:u.fetchMore,d</span>=<span class="cstat-no" title="statement not covered" >null==h?void 0:h.pageParam,f</span>=<span class="cstat-no" title="statement not covered" >(null==h?void 0:h.direction)==="forward",p</span>=<span class="cstat-no" title="statement not covered" >(null==h?void 0:h.direction)==="backward",v</span>=<span class="cstat-no" title="statement not covered" >(null==(o=t.state.data)?void 0:o.pages)||[],</span>y=<span class="cstat-no" title="statement not covered" >(null==(a=t.state.data)?void 0:a.pageParams)||[],</span>b=<span class="cstat-no" title="statement not covered" >y,m</span>=<span class="cstat-no" title="statement not covered" >!1,g</span>=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=&gt;{<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(e,"signal",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >()=&gt;{v</span>ar e,r;<span class="cstat-no" title="statement not covered" >return null!=(e=t.signal)&amp;&amp;e.aborted?m=!0:null==(r=t.signal)||r.addEventListener("abort",<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >m</span>=!0}</span>),t.signal}</span>})}</span>,R</span>=<span class="cstat-no" title="statement not covered" >t.options.queryFn||(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >P</span>romise.reject("Missing queryFn for queryKey '"+t.options.queryHash+"'")</span>),O</span>=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,r,s)=&gt;(<span class="cstat-no" title="statement not covered" >b=s?[e,...b]:[...b,e],s?[r,...t]:[...t,r]</span></span>),E=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,r,s,i)=&gt;{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(m)<span class="cstat-no" title="statement not covered" >return Promise.reject("Cancelled");<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(void 0===s&amp;&amp;!r&amp;&amp;e.length)<span class="cstat-no" title="statement not covered" >return Promise.resolve(e);l</span></span>et n=<span class="cstat-no" title="statement not covered" >{queryKey:t.queryKey,pageParam:s,meta:t.options.meta};<span class="cstat-no" title="statement not covered" >g</span>(n);l</span>et u=<span class="cstat-no" title="statement not covered" >R(n),o</span>=<span class="cstat-no" title="statement not covered" >Promise.resolve(u).then(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >O</span>(e,s,t,i));<span class="cstat-no" title="statement not covered" >r</span></span>eturn o}</span>;<span class="cstat-no" title="statement not covered" >i</span>f(v.length){<span class="cstat-no" title="statement not covered" >if(f){let e=<span class="cstat-no" title="statement not covered" >void 0!==d,r</span>=<span class="cstat-no" title="statement not covered" >e?d:i(t.options,v);<span class="cstat-no" title="statement not covered" >l</span>=E(v,e,r)}</span>else <span class="cstat-no" title="statement not covered" >if(p){let e=<span class="cstat-no" title="statement not covered" >void 0!==d,r</span>=<span class="cstat-no" title="statement not covered" >e?d:n(t.options,v);<span class="cstat-no" title="statement not covered" >l</span>=E(v,e,r,!0)}</span>else{<span class="cstat-no" title="statement not covered" >b=[];l</span>et e=<span class="cstat-no" title="statement not covered" >void 0===t.options.getNextPageParam,r</span>=<span class="cstat-no" title="statement not covered" >!c||!v[0]||c(v[0],0,v);<span class="cstat-no" title="statement not covered" >l</span>=r?E([],e,y[0]):Promise.resolve(O([],y[0],v[0]));<span class="cstat-no" title="statement not covered" >f</span>or(let r=<span class="cstat-no" title="statement not covered" >1;r</span>&lt;v.length;r++)<span class="cstat-no" title="statement not covered" >l=l.then(<span class="fstat-no" title="function not covered" >s=&gt;{l</span>et n=<span class="cstat-no" title="statement not covered" >!c||!v[r]||c(v[r],r,v);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(n){let n=<span class="cstat-no" title="statement not covered" >e?y[r]:i(t.options,s);<span class="cstat-no" title="statement not covered" >r</span>eturn E(s,e,n)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn Promise.resolve(O(s,y[r],v[r]))}</span>)}</span></span>}</span></span>else <span class="cstat-no" title="statement not covered" >l=E([]);l</span></span>et S=<span class="cstat-no" title="statement not covered" >l.then(<span class="fstat-no" title="function not covered" >t=&gt;(<span class="cstat-no" title="statement not covered" >{</span>pages:t,pageParams:b}));<span class="cstat-no" title="statement not covered" >r</span></span>eturn S}</span>}</span>}}</span>function <span class="fstat-no" title="function not covered" >i(t</span>,e){<span class="cstat-no" title="statement not covered" >return null==t.getNextPageParam?void 0:t.getNextPageParam(e[e.length-1],e)}</span>function <span class="fstat-no" title="function not covered" >n(t</span>,e){<span class="cstat-no" title="statement not covered" >return null==t.getPreviousPageParam?void 0:t.getPreviousPageParam(e[0],e)}</span>function <span class="fstat-no" title="function not covered" >u(t</span>,e){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t.getNextPageParam&amp;&amp;Array.isArray(e)){let r=<span class="cstat-no" title="statement not covered" >i(t,e);<span class="cstat-no" title="statement not covered" >r</span>eturn null!=r&amp;&amp;!1!==r}</span>}</span>function <span class="fstat-no" title="function not covered" >o(t</span>,e){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t.getPreviousPageParam&amp;&amp;Array.isArray(e)){let r=<span class="cstat-no" title="statement not covered" >n(t,e);<span class="cstat-no" title="statement not covered" >r</span>eturn null!=r&amp;&amp;!1!==r}</span>}<span class="cstat-no" title="statement not covered" ></span>r.d(e,{Gm:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn s}</span>,Qy:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn u}</span>,ZF:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn o}</span>})}</span>,1091:<span class="fstat-no" title="function not covered" >function(t</span>,e,r){<span class="cstat-no" title="statement not covered" >r.d(e,{z:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn a}</span>});v</span>ar s=<span class="cstat-no" title="statement not covered" >r(3199),i</span>=<span class="cstat-no" title="statement not covered" >r(324),n</span>=<span class="cstat-no" title="statement not covered" >r(3908),u</span>=<span class="cstat-no" title="statement not covered" >r(3131),o</span>=<span class="cstat-no" title="statement not covered" >r(2425);c</span>lass a extends u.l{<span class="fstat-no" title="function not covered" >constructor(t</span>,e){<span class="cstat-no" title="statement not covered" >super(),this.client=t,this.options=e,this.trackedProps=new Set,this.selectError=null,this.bindMethods(),this.setOptions(e)}<span class="fstat-no" title="function not covered" ></span>bindMethods(){<span class="cstat-no" title="statement not covered" ></span>this.remove=this.remove.bind(this),this.refetch=this.refetch.bind(this)}<span class="fstat-no" title="function not covered" ></span>onSubscribe(){<span class="cstat-no" title="statement not covered" ></span>1===this.listeners.size&amp;&amp;(this.currentQuery.addObserver(this),l(this.currentQuery,this.options)&amp;&amp;this.executeFetch(),this.updateTimers())}<span class="fstat-no" title="function not covered" ></span>onUnsubscribe(){<span class="cstat-no" title="statement not covered" ></span>this.hasListeners()||this.destroy()}<span class="fstat-no" title="function not covered" ></span>shouldFetchOnReconnect(){<span class="cstat-no" title="statement not covered" ></span>return c(this.currentQuery,this.options,this.options.refetchOnReconnect)}<span class="fstat-no" title="function not covered" ></span>shouldFetchOnWindowFocus(){<span class="cstat-no" title="statement not covered" ></span>return c(this.currentQuery,this.options,this.options.refetchOnWindowFocus)}<span class="fstat-no" title="function not covered" ></span>destroy(){<span class="cstat-no" title="statement not covered" ></span>this.listeners=new Set,this.clearStaleTimeout(),this.clearRefetchInterval(),this.currentQuery.removeObserver(this)}<span class="fstat-no" title="function not covered" ></span>setOptions(t</span>,e){let r=<span class="cstat-no" title="statement not covered" >this.options,i</span>=<span class="cstat-no" title="statement not covered" >this.currentQuery;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(this.options=this.client.defaultQueryOptions(t),(0,s.VS)(r,this.options)||this.client.getQueryCache().notify({type:"observerOptionsUpdated",query:this.currentQuery,observer:this}),void 0!==this.options.enabled&amp;&amp;"boolean"!=typeof this.options.enabled)<span class="cstat-no" title="statement not covered" >throw Error("Expected enabled to be a boolean");<span class="cstat-no" title="statement not covered" >t</span></span>his.options.queryKey||(this.options.queryKey=r.queryKey),this.updateQuery();l</span>et n=<span class="cstat-no" title="statement not covered" >this.hasListeners();<span class="cstat-no" title="statement not covered" >n</span>&amp;&amp;h(this.currentQuery,i,this.options,r)&amp;&amp;this.executeFetch(),this.updateResult(e),n&amp;&amp;(this.currentQuery!==i||this.options.enabled!==r.enabled||this.options.staleTime!==r.staleTime)&amp;&amp;this.updateStaleTimeout();l</span>et u=<span class="cstat-no" title="statement not covered" >this.computeRefetchInterval();<span class="cstat-no" title="statement not covered" >n</span>&amp;&amp;(this.currentQuery!==i||this.options.enabled!==r.enabled||u!==this.currentRefetchInterval)&amp;&amp;this.updateRefetchInterval(u)}<span class="fstat-no" title="function not covered" ></span>getOptimisticResult(t</span>){let e=<span class="cstat-no" title="statement not covered" >this.client.getQueryCache().build(this.client,t);<span class="cstat-no" title="statement not covered" >r</span>eturn this.createResult(e,t)}<span class="fstat-no" title="function not covered" ></span>getCurrentResult(){<span class="cstat-no" title="statement not covered" ></span>return this.currentResult}<span class="fstat-no" title="function not covered" ></span>trackResult(t</span>){let e=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" >r</span>eturn Object.keys(t).forEach(<span class="fstat-no" title="function not covered" >r=&gt;{<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(e,r,{configurable:!1,enumerable:!0,get:<span class="fstat-no" title="function not covered" >()=&gt;(<span class="cstat-no" title="statement not covered" >t</span>his.trackedProps.add(r),t[r]</span>)})}</span>),e}<span class="fstat-no" title="function not covered" ></span>getCurrentQuery(){<span class="cstat-no" title="statement not covered" ></span>return this.currentQuery}<span class="fstat-no" title="function not covered" ></span>remove(){<span class="cstat-no" title="statement not covered" ></span>this.client.getQueryCache().remove(this.currentQuery)}<span class="fstat-no" title="function not covered" ></span>refetch({</span>refetchPage:t,...e}=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return this.fetch({...e,meta:{refetchPage:t}})}<span class="fstat-no" title="function not covered" ></span>fetchOptimistic(t</span>){let e=<span class="cstat-no" title="statement not covered" >this.client.defaultQueryOptions(t),r</span>=<span class="cstat-no" title="statement not covered" >this.client.getQueryCache().build(this.client,e);<span class="cstat-no" title="statement not covered" >r</span>eturn r.isFetchingOptimistic=!0,r.fetch().then(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >t</span>his.createResult(r,e))}<span class="fstat-no" title="function not covered" ></span></span>fetch(t</span>){var e;<span class="cstat-no" title="statement not covered" >return this.executeFetch({...t,cancelRefetch:null==(e=t.cancelRefetch)||e}).then(<span class="fstat-no" title="function not covered" >()=&gt;(<span class="cstat-no" title="statement not covered" >t</span>his.updateResult(),this.currentResult</span>))}<span class="fstat-no" title="function not covered" ></span>executeFetch(t</span>){<span class="cstat-no" title="statement not covered" >this.updateQuery();l</span>et e=<span class="cstat-no" title="statement not covered" >this.currentQuery.fetch(this.options,t);<span class="cstat-no" title="statement not covered" >r</span>eturn null!=t&amp;&amp;t.throwOnError||(e=e.catch(s.ZT)),e}<span class="fstat-no" title="function not covered" ></span>updateStaleTimeout(){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(this.clearStaleTimeout(),s.sk||this.currentResult.isStale||!(0,s.PN)(this.options.staleTime))<span class="cstat-no" title="statement not covered" >return;l</span></span>et t=<span class="cstat-no" title="statement not covered" >(0,s.Kp)(this.currentResult.dataUpdatedAt,this.options.staleTime);<span class="cstat-no" title="statement not covered" >t</span>his.staleTimeoutId=setTimeout(<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >t</span>his.currentResult.isStale||this.updateResult()}</span>,t+1)}<span class="fstat-no" title="function not covered" ></span>computeRefetchInterval(){</span>var t;<span class="cstat-no" title="statement not covered" >return"function"==typeof this.options.refetchInterval?this.options.refetchInterval(this.currentResult.data,this.currentQuery):null!=(t=this.options.refetchInterval)&amp;&amp;t}<span class="fstat-no" title="function not covered" ></span>updateRefetchInterval(t</span>){<span class="cstat-no" title="statement not covered" >this.clearRefetchInterval(),this.currentRefetchInterval=t,!s.sk&amp;&amp;!1!==this.options.enabled&amp;&amp;(0,s.PN)(this.currentRefetchInterval)&amp;&amp;0!==this.currentRefetchInterval&amp;&amp;(this.refetchIntervalId=setInterval(<span class="fstat-no" title="function not covered" >()=&gt;{(<span class="cstat-no" title="statement not covered" >t</span>his.options.refetchIntervalInBackground||n.j.isFocused())&amp;&amp;this.executeFetch()}</span>,this.currentRefetchInterval))}<span class="fstat-no" title="function not covered" ></span>updateTimers(){<span class="cstat-no" title="statement not covered" ></span>this.updateStaleTimeout(),this.updateRefetchInterval(this.computeRefetchInterval())}<span class="fstat-no" title="function not covered" ></span>clearStaleTimeout(){<span class="cstat-no" title="statement not covered" ></span>this.staleTimeoutId&amp;&amp;(clearTimeout(this.staleTimeoutId),this.staleTimeoutId=void 0)}<span class="fstat-no" title="function not covered" ></span>clearRefetchInterval(){<span class="cstat-no" title="statement not covered" ></span>this.refetchIntervalId&amp;&amp;(clearInterval(this.refetchIntervalId),this.refetchIntervalId=void 0)}<span class="fstat-no" title="function not covered" ></span>createResult(t</span>,e){let r;let i=<span class="cstat-no" title="statement not covered" >this.currentQuery,n</span>=<span class="cstat-no" title="statement not covered" >this.options,u</span>=<span class="cstat-no" title="statement not covered" >this.currentResult,a</span>=<span class="cstat-no" title="statement not covered" >this.currentResultState,c</span>=<span class="cstat-no" title="statement not covered" >this.currentResultOptions,f</span>=<span class="cstat-no" title="statement not covered" >t!==i,p</span>=<span class="cstat-no" title="statement not covered" >f?t.state:this.currentQueryInitialState,v</span>=<span class="cstat-no" title="statement not covered" >f?this.currentResult:this.previousQueryResult,{</span>state:y}=<span class="cstat-no" title="statement not covered" >t,{</span>dataUpdatedAt:b,error:m,errorUpdatedAt:g,fetchStatus:R,status:O}=<span class="cstat-no" title="statement not covered" >y,E</span>=<span class="cstat-no" title="statement not covered" >!1,S</span>=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(e._optimisticResults){let r=<span class="cstat-no" title="statement not covered" >this.hasListeners(),s</span>=<span class="cstat-no" title="statement not covered" >!r&amp;&amp;l(t,e),u</span>=<span class="cstat-no" title="statement not covered" >r&amp;&amp;h(t,i,e,n);(<span class="cstat-no" title="statement not covered" >s</span>||u)&amp;&amp;(R=(0,o.Kw)(t.options.networkMode)?"fetching":"paused",b||(O="loading")),"isRestoring"===e._optimisticResults&amp;&amp;(R="idle")}<span class="cstat-no" title="statement not covered" ></span>i</span>f(e.keepPreviousData&amp;&amp;!y.dataUpdatedAt&amp;&amp;null!=v&amp;&amp;v.isSuccess&amp;&amp;"error"!==O)<span class="cstat-no" title="statement not covered" >r=v.data,b=v.dataUpdatedAt,O=v.status,E=!0;else <span class="cstat-no" title="statement not covered" >i</span>f(e.select&amp;&amp;void 0!==y.data){<span class="cstat-no" title="statement not covered" >if(u&amp;&amp;y.data===(null==a?void 0:a.data)&amp;&amp;e.select===this.selectFn)<span class="cstat-no" title="statement not covered" >r=this.selectResult;else <span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >this.selectFn=e.select,r=e.select(y.data),r=(0,s.oE)(null==u?void 0:u.data,r,e),this.selectResult=r,this.selectError=null}</span>catch(t){<span class="cstat-no" title="statement not covered" >this.selectError=t}</span>}</span></span>else <span class="cstat-no" title="statement not covered" >r=y.data;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span></span>f(void 0!==e.placeholderData&amp;&amp;void 0===r&amp;&amp;"loading"===O){let t;<span class="cstat-no" title="statement not covered" >if(null!=u&amp;&amp;u.isPlaceholderData&amp;&amp;e.placeholderData===(null==c?void 0:c.placeholderData))<span class="cstat-no" title="statement not covered" >t=u.data;else <span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(t="function"==typeof e.placeholderData?e.placeholderData():e.placeholderData,e.select&amp;&amp;void 0!==t)<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >t=e.select(t),this.selectError=null}</span>catch(t){<span class="cstat-no" title="statement not covered" >this.selectError=t}<span class="cstat-no" title="statement not covered" ></span>v</span></span></span>oid 0!==t&amp;&amp;(O="success",r=(0,s.oE)(null==u?void 0:u.data,t,e),S=!0)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.selectError&amp;&amp;(m=this.selectError,r=this.selectResult,g=Date.now(),O="error");l</span>et Q=<span class="cstat-no" title="statement not covered" >"fetching"===R,C</span>=<span class="cstat-no" title="statement not covered" >"loading"===O,P</span>=<span class="cstat-no" title="statement not covered" >"error"===O,M</span>=<span class="cstat-no" title="statement not covered" >{status:O,fetchStatus:R,isLoading:C,isSuccess:"success"===O,isError:P,isInitialLoading:C&amp;&amp;Q,data:r,dataUpdatedAt:b,error:m,errorUpdatedAt:g,failureCount:y.fetchFailureCount,failureReason:y.fetchFailureReason,errorUpdateCount:y.errorUpdateCount,isFetched:y.dataUpdateCount&gt;0||y.errorUpdateCount&gt;0,isFetchedAfterMount:y.dataUpdateCount&gt;p.dataUpdateCount||y.errorUpdateCount&gt;p.errorUpdateCount,isFetching:Q,isRefetching:Q&amp;&amp;!C,isLoadingError:P&amp;&amp;0===y.dataUpdatedAt,isPaused:"paused"===R,isPlaceholderData:S,isPreviousData:E,isRefetchError:P&amp;&amp;0!==y.dataUpdatedAt,isStale:d(t,e),refetch:this.refetch,remove:this.remove};<span class="cstat-no" title="statement not covered" >r</span>eturn M}<span class="fstat-no" title="function not covered" ></span>updateResult(t</span>){let e=<span class="cstat-no" title="statement not covered" >this.currentResult,r</span>=<span class="cstat-no" title="statement not covered" >this.createResult(this.currentQuery,this.options);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(this.currentResultState=this.currentQuery.state,this.currentResultOptions=this.options,(0,s.VS)(r,e))<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.currentResult=r;l</span>et i=<span class="cstat-no" title="statement not covered" >{cache:!0};(<span class="cstat-no" title="statement not covered" >n</span>ull==t?void 0:t.listeners)!==!1&amp;&amp;(<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!e)<span class="cstat-no" title="statement not covered" >return!0;l</span></span>et{notifyOnChangeProps:t}=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f("all"===t||!t&amp;&amp;!this.trackedProps.size)<span class="cstat-no" title="statement not covered" >return!0;l</span></span>et r=<span class="cstat-no" title="statement not covered" >new Set(null!=t?t:this.trackedProps);<span class="cstat-no" title="statement not covered" >r</span>eturn this.options.useErrorBoundary&amp;&amp;r.add("error"),Object.keys(this.currentResult).some(<span class="fstat-no" title="function not covered" >t=&gt;{l</span>et s=<span class="cstat-no" title="statement not covered" >this.currentResult[t]!==e[t];<span class="cstat-no" title="statement not covered" ></span>return s&amp;&amp;r.has(t)}</span>)}</span>)()&amp;&amp;(i.listeners=!0),this.notify({...i,...t})}<span class="fstat-no" title="function not covered" ></span>updateQuery(){</span>let t=<span class="cstat-no" title="statement not covered" >this.client.getQueryCache().build(this.client,this.options);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(t===this.currentQuery)<span class="cstat-no" title="statement not covered" >return;l</span></span>et e=<span class="cstat-no" title="statement not covered" >this.currentQuery;<span class="cstat-no" title="statement not covered" >t</span>his.currentQuery=t,this.currentQueryInitialState=t.state,this.previousQueryResult=this.currentResult,this.hasListeners()&amp;&amp;(null==e||e.removeObserver(this),t.addObserver(this))}<span class="fstat-no" title="function not covered" ></span>onQueryUpdate(t</span>){let e=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" >"</span>success"===t.type?e.onSuccess=!t.manual:"error"!==t.type||(0,o.DV)(t.error)||(e.onError=!0),this.updateResult(e),this.hasListeners()&amp;&amp;this.updateTimers()}<span class="fstat-no" title="function not covered" ></span>notify(t</span>){<span class="cstat-no" title="statement not covered" >i.V.batch(<span class="fstat-no" title="function not covered" >()=&gt;{v</span>ar e,r,s,i,n,u,o,a;<span class="cstat-no" title="statement not covered" >t.onSuccess?(null==(e=(r=this.options).onSuccess)||e.call(r,this.currentResult.data),null==(s=(i=this.options).onSettled)||s.call(i,this.currentResult.data,null)):t.onError&amp;&amp;(null==(n=(u=this.options).onError)||n.call(u,this.currentResult.error),null==(o=(a=this.options).onSettled)||o.call(a,void 0,this.currentResult.error)),t.listeners&amp;&amp;this.listeners.forEach(<span class="fstat-no" title="function not covered" >({</span>listener:t})=&gt;{<span class="cstat-no" title="statement not covered" >t(this.currentResult)}</span>),t.cache&amp;&amp;this.client.getQueryCache().notify({query:this.currentQuery,type:"observerResultsUpdated"})}</span>)}</span>}function <span class="fstat-no" title="function not covered" >l(t</span>,e){<span class="cstat-no" title="statement not covered" >return!1!==e.enabled&amp;&amp;!t.state.dataUpdatedAt&amp;&amp;!("error"===t.state.status&amp;&amp;!1===e.retryOnMount)||t.state.dataUpdatedAt&gt;0&amp;&amp;c(t,e,e.refetchOnMount)}</span>function <span class="fstat-no" title="function not covered" >c(t</span>,e,r){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!1!==e.enabled){let s=<span class="cstat-no" title="statement not covered" >"function"==typeof r?r(t):r;<span class="cstat-no" title="statement not covered" >r</span>eturn"always"===s||!1!==s&amp;&amp;d(t,e)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!1}</span>function <span class="fstat-no" title="function not covered" >h(t</span>,e,r,s){<span class="cstat-no" title="statement not covered" >return!1!==r.enabled&amp;&amp;(t!==e||!1===s.enabled)&amp;&amp;(!r.suspense||"error"!==t.state.status)&amp;&amp;d(t,r)}</span>function <span class="fstat-no" title="function not covered" >d(t</span>,e){<span class="cstat-no" title="statement not covered" >return t.isStaleByTime(e.staleTime)}</span>}}]);</pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank" rel="noopener noreferrer">istanbul</a>
                at 2023-07-28T11:41:41.928Z
            </div>
        <script src="../../../../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../../../../sorter.js"></script>
        <script src="../../../../block-navigation.js"></script>
    </body>
</html>
    